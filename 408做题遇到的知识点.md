## 数据冒险
流水线中指令执行次序颠倒后可能导致结果错误。不存在数据冒险即颠倒指令顺序不影响执行结果

## 磁盘的最小读写单位
从应用程序包括用户界面的角度来看，存取信息的最小单位是Byte（字节）

从磁盘的物理结构来看存取信息的最小单位是扇区，一个扇区是512字节

从操作系统对硬盘的存取管理来看，存取信息的最小单位是簇

## DMA
DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术

每类设备都配置一个设备驱动程序，设备驱动程序向上层用户提供一组标准接口，负责实现对设备发出各种具体操作指令，用户程序不能直接和DMA打交道。DMA的数据传送过程分为预处理、数据传送和后处理三个阶段

**预处理阶段**：由CPU完成必要的准备工作，数据传送前由DMA控制器请求总线使用权

**数据传送阶段**：DMA控制器直接控制总线完成

**传送结束后**：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理

## 用户级线程和内核级线程
内核级线程的调度由操作系统完成

多线程模型中用户级线程和内核级线程的连接方式分为多对一、一对一、多对多

用户级线程的切换可在用户空间完成，内核级线程的切换需要操作系统帮助进行调度，故**用户及线程的切换效率更高**

用户级线程的管理工作可以只在用户空间中进行，故可以在不支持内核级线程的操作系统上实现

## 动态内存分配算法
最佳适应算法最容易产生内存碎片

## 各种宽带传输介质
100Base-T 双绞线

100Base-Sx 单模光纤

100Base-Fx 多模光纤

## 滑动窗口大小限制
停止等待协议：发送窗口=1，接收窗口=1

后退N步协议：发送窗口>1，接收窗口=1

选择重传：发送窗口>1，接收窗口>1。  
发送窗口大小+接收窗口大小$\leq 2^n$  
接收窗口大小$\leq$发送窗口大小，接受窗口大小不应超过序号范围的一半即$\leq 2^{(n-1)}$

## 大端和小端
32bit宽的16进制 0x12345678 在内存中的存放方式：

**在内存表示中，左边的是低地址，右边的是高地址**

大端： 高字节存储在低地址，低字节存储在高地址

内存地址|	0x4000|	0x4001|	0x4002|	0x4003
-------|---------|-------|-------|-------
存放内容|	0x12|	0x34|	0x56|	0x78

小端： 低字节存储在低地址，高字节存储在高地址

内存地址|	0x4000|	0x4001|	0x4002|	0x4003
-------|---------|-------|-------|-------
存放内容|	0x78|	0x56|	0x34|	0x12

## 相对寻址
目标地址=（PC）+偏移量

## 主存地址组成
主存标记 |组号 |块内地址

组号位数由组的个数决定。假设Cache总共64行，采用4路组相联。一个组含有几块称为几路组相联。则组数=64/4=16。2^4^=16，因此需要4位组号

块内地址位数由主存块大小决定。设主存块大小为64B。2^6^=64。因此需要6位块内地址

除去组号和块内地址，剩下的位数即为主存标记

## B树
### 为什么要用B树？   
二叉树和B树查找的时间复杂度相同，均为O(logN)。但二叉树查找时需要频繁切换节点，不同节点的读取会导致磁盘IO操作（最坏情况是读取树的高度次），效率低下。为了减少磁盘IO的次数，就必须降低树的深度，将“瘦高”的树变得“矮胖”。
### 和二叉树的区别
二叉树以2为最大基准向下延伸，而B树则没有标准，所以它可以变得矮矮胖胖的。
### B树的性质
B 树又叫平衡多路查找树

**阶的含义**：描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母M表示阶数

**根节点子节点个数最小值限制**：根结点至少有两个子节点

**除根节点以外的非叶子节点的子节点个数最小值限制**：除根节点和叶节点外，其余所有节点至少有m/2棵子树（向上取整）

**所有的叶子结点都位于同一层**

## 堆
堆具有以下的特点：
1）完全二叉树；
2）heap中存储的值是偏序；

小根堆: 父节点的值小于或等于子节点的值；
大根堆: 父节点的值大于或等于子节点的值；

### 构建大根堆
1.从最后一个非叶子节点为父节点的子树出发，从右往左，从下往上进行调整操作（怎么调整下面讲）。这里需注意的是：

a.是以该非叶子节点为父节点的子树，即该父节点以下的所有部分都进行调整操作。

b.由于是从右往左从下往上，则某一步进行调整时在调整它之前的那些子树已经是堆有序了，即走到某个非叶子节点时，它的子树已经是堆有序了（因为是从下往上）

2.即调整函数 :

a.如果该节点比它的两个孩子节点都大，则该节点不用调整了，因为它的孩子节点也是堆有序 （上面b已说明）

b.如果该节点比它的两个子节点中的较大节点小，即array[i]< max(array[2i],array[2i+1]），将array[i]赋给temp，以后每次都跟temp比较，好多博客说的是交换两个值，其实程序里是直接比较temp。将max(array[2i],array[2i+1])赋给array[i]。接着从max(array[2i],array[2i+1]) 对应的那个节点出发，继续进行该操作，直到该节点到达了n。当然每次判断边界条件为左子树的索引小于n，则右子树才有值