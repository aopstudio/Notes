# 一些简称
* CPI：指令时钟周期
* RTT：往返时延
* MST：最小生成树

## 数据冒险
流水线使原先有先后顺序的指令同时处理，当出现某些指令的组合时，可能会导致指令使用了错误的数据，主要看使用的数据会不会被影响，而不是最终结果是否变化

## 磁盘的最小读写单位
* 字节：从应用程序包括用户界面的角度来看，存取信息的最小单位是

* 扇区：从磁盘的物理结构来看存取信息的最小单位，一般一个扇区是512字节

* 簇：从操作系统对硬盘的存取管理来看，是存取信息的最小单位，即最小分配单位。

## DMA
DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术

每类设备都配置一个设备驱动程序，设备驱动程序向上层用户提供一组标准接口，负责实现对设备发出各种具体操作指令，用户程序不能直接和DMA打交道。DMA的数据传送过程分为预处理、数据传送和后处理三个阶段

**预处理阶段**：由CPU完成必要的准备工作，数据传送前由DMA控制器请求总线使用权

**数据传送阶段**：DMA控制器直接控制总线完成

**传送结束后**：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理

## 用户级线程和内核级线程
内核级线程的调度由操作系统完成

多线程模型中用户级线程和内核级线程的连接方式分为多对一、一对一、多对多

用户级线程的切换可在用户空间完成，内核级线程的切换需要操作系统帮助进行调度，故**用户及线程的切换效率更高**

用户级线程的管理工作可以只在用户空间中进行，故可以在不支持内核级线程的操作系统上实现

## 动态内存分配算法
最佳适应算法最容易产生内存碎片

## 各种宽带传输介质
100Base-T 双绞线

100Base-Sx 单模光纤

100Base-Fx 多模光纤

## 滑动窗口大小限制
停止等待协议：发送窗口=1，接收窗口=1

后退N步协议：发送窗口>1，接收窗口=1。序号个数>=发送窗口+1，即发送窗口<=序号个数-1即可

选择重传：发送窗口>1，接收窗口>1。  
发送窗口大小+接收窗口大小$\leq 2^n$  
接收窗口大小$\leq$发送窗口大小，接受窗口大小不应超过序号范围的一半即$\leq 2^{(n-1)}$

## 大端和小端
32bit宽的16进制 0x12345678 在内存中的存放方式：

**在内存表示中，左边的是低地址，右边的是高地址**

大端： 高字节存储在低地址，低字节存储在高地址

内存地址|	0x4000|	0x4001|	0x4002|	0x4003
-------|---------|-------|-------|-------
存放内容|	0x12|	0x34|	0x56|	0x78

小端： 低字节存储在低地址，高字节存储在高地址

内存地址|	0x4000|	0x4001|	0x4002|	0x4003
-------|---------|-------|-------|-------
存放内容|	0x78|	0x56|	0x34|	0x12

## 相对寻址
目标地址=（PC）+偏移量

## 主存地址组成
主存标记 |组号 |块内地址

组号位数由组的个数决定。假设Cache总共64行，采用4路组相联。一个组含有几块称为几路组相联。则组数=64/4=16。2^4^=16，因此需要4位组号

块内地址位数由主存块大小决定。设主存块大小为64B。2^6^=64。因此需要6位块内地址

除去组号和块内地址，剩下的位数即为主存标记

## B树
### 为什么要用B树？   
二叉树和B树查找的时间复杂度相同，均为O(logN)。但二叉树查找时需要频繁切换节点，不同节点的读取会导致磁盘IO操作（最坏情况是读取树的高度次），效率低下。为了减少磁盘IO的次数，就必须降低树的深度，将“瘦高”的树变得“矮胖”。
### 和二叉树的区别
二叉树以2为最大基准向下延伸，而B树则没有标准，所以它可以变得矮矮胖胖的。
### B树的性质
B 树又叫平衡多路查找树

**阶的含义**：描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母M表示阶数

**根节点子节点个数最小值限制**：根结点至少有两个子节点

**除根节点以外的非叶子节点的子节点个数最小值限制**：除根节点和叶节点外，其余所有节点至少有m/2棵子树（向上取整）

**所有的叶子结点都位于同一层**

## 堆
堆具有以下的特点：
1）完全二叉树；
2）heap中存储的值是偏序；

小根堆: 父节点的值小于或等于子节点的值；
大根堆: 父节点的值大于或等于子节点的值；

### 构建大根堆
1.从最后一个非叶子节点为父节点的子树出发，从右往左，从下往上进行调整操作（怎么调整下面讲）。这里需注意的是：

a.是以该非叶子节点为父节点的子树，即该父节点以下的所有部分都进行调整操作。

b.由于是从右往左从下往上，则某一步进行调整时在调整它之前的那些子树已经是堆有序了，即走到某个非叶子节点时，它的子树已经是堆有序了（因为是从下往上）

2.即调整函数 :

a.如果该节点比它的两个孩子节点都大，则该节点不用调整了，因为它的孩子节点也是堆有序 （上面b已说明）

b.如果该节点比它的两个子节点中的较大节点小，即array[i]< max(array[2i],array[2i+1]），将array[i]赋给temp，以后每次都跟temp比较，好多博客说的是交换两个值，其实程序里是直接比较temp。将max(array[2i],array[2i+1])赋给array[i]。接着从max(array[2i],array[2i+1]) 对应的那个节点出发，继续进行该操作，直到该节点到达了n。当然每次判断边界条件为左子树的索引小于n，则右子树才有值

## 希尔排序
首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高

![](http://p1.pstatp.com/large/pgc-image/1523763390411731c4d486d)

每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序）
![](http://p9.pstatp.com/large/pgc-image/1523763390605f1acc654c8)

然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比高
![](http://p3.pstatp.com/large/pgc-image/15237633906876d1db94cf9)

同理对每个分组进行排序（插入排序），使其每个分组各自有序

![](http://p9.pstatp.com/large/pgc-image/1523763390761f7f32df528)

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高

![](http://p3.pstatp.com/large/pgc-image/152376339087072702782c5)

## IEEE 754
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574950291804&di=f2ab3b418f211194c8db413d1d2abab9&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D2939187830%2C3295967069%26fm%3D214%26gp%3D0.jpg)

阶码全1，尾数全0表示无穷大
## 逻辑移位和算术移位
逻辑移位：左移和右移空位都补0，并且所有数字参与移动

算术移位：符号位不参与移动，右移空位补符号位，左移空位补0

## 周转时间和等待时间
周转时间=作业完成时间-进入作业队列时间

等待时间=作业开始时间-进入作业队列时间

## C语言动态数组定义并赋初值0
假设要定义一个含有n个元素的数组A，并给所有元素赋初值位0，代码如下
```c
int *A;
A=(int *)malloc(sizeof(int)*n); 
memset(A,0,sizeof(int)*n);
```

## 物理地址和逻辑地址相关
物理地址位数=实页号位数+页内地址位数

## TLB
TLB采用全相联映射，采用SRAM实现

## 虚拟地址结构
虚页号 | 页内地址

虚页号又可分为：页目录号 | 页号

## 各种寄存器
### PDBR（页目录基址地址寄存器）
其存储页目录表物理内存基地址。进程切换时，PDBR的内容会变化；同一进程的线程切换时，PDBR的内容不会变化。每个进程的地址空间、页目录和PDBR的内容存在一一对应的关系。进程切换时，地址空间发生了变化，对应的页目录及其起始地址也相应变化，因此需要用进程切换后当前进程的页目录起始地址刷新PDBR。同一进程中的线程共享该进程的地址空间，其线程发生切换时，线程使用的页目录不变，因此PDBR的内容也不变。

## 置换算法
### 简单的CLOCK置换算法
需要一个**附加位**，也叫**使用位**

主要思想：当某一页装入主存时，将use bit置成1；如果该页之后又被访问到，使用位也还是标记成1。对于页面置换算法，候选的帧集合可以看成是一个循环缓冲区，并且有一个指针和缓冲区相关联。遇到页面替换时，指针指向缓冲区的下一帧。若所有页面的使用位均为1，那么这时候从指针开始循环一个缓冲区，将之前的使用位都清0，并且留在最初的位置上，换出该帧对应的页。若存在使用位为0的元素，则当有新元素要进入时，置换离指针最近的使用位为0的元素。

### 改进型CLOCK置换算法
在之前的CLOCK算法上面除了使用位(used bit)，还增加了一个修改位(modified bit)，有些地方也叫做**脏位**（dirty bit）。现在每一页有两个状态，分别是(使用位，修改位)，可以分以下四种情况：

* (0,0)：最近没有使用使用也没有修改，最佳状态！
* (0,1)：修改过但最近没有使用，将会被写
* (1,0)：使用过但没有被修改，下一轮将再次被用
* (1,1)：使用过也修改过，下一轮页面置换最后的选择

页面替换的顺序：  
从指针当前的位置开始寻找主存中满足(使用位，修改位)为(0,0)的页面；
如果第1步没有找到满足条件的，接着寻找状态为(0,1)页面；
如果依然没有找到，指针回到最初的位置，将集合中所有页面的使用位设置成0。重复第1步，并且如果有必要，重复第2步，这样一定可以找到将要替换的页面。

## 广播地址
主机号全1

## 分片
片偏移就是某片在原分组的相对位置，以8个字节为偏移单位。**这就是说，每个分片的长度一定是8字节（64位）的整数倍。**

## 三元组表、十字链表
**都用于稀疏矩阵的存储**

三元组表：存储非零元素的行标、列标和元素值的线性表

十字链表：除了存放三元组表的三个元素，还要存放横向的下一个非零节点的地址和纵向的下一个非零节点的地址，即每行为一个链表，每列为一个链表

## 图的边和顶点度数的关系
无向图边的两倍是顶点度数的总和

## 折半查找判定树
实际上是一棵二叉排序树，它的中序序列是一个有序序列

构建时，取中间值时要么全部向上取整，要么全部向下取整。不能出现有的区间向上取整，有的区间向下取整的情况

## 和顺序存储相比，链式存储算法时间效率
插入排序、选择排序、冒泡排序不变，都是$O(n^2)$

希尔排序和堆排序都利用了顺序存储的随机访问特性，时间复杂度会增加

## 访问局部性
CPU访问中的局部性原理
主要两点：时间与空间

* 时间局部性：理解的关键点在于“访问的时间间隔”，比如for循环实现sum求和，sum就是这次访问了，下次还被访问，体现的就是时间局部性。
* 空间局部性：理解的关键点“存储的位置”，相邻的数据很可能被一同访问到。cache的基本原理就体现了这一点。
数组和链表通常具有很好的空间局部性

## 寻址
### 变址寻址
将计算机指令中的地址与变址寄存器中的地址相加，得到有效地址。适合按下标顺序访问一维数组元素，指令提供数组首地址，由变址寄存器来定位数据中的各元素

### 相对寻址
以PC为基地址，以指令中的地址为偏移量确定有效地址
### 寄存器寻址
在指令中指出需要使用的寄存器

## 控制存储器（CM）
在CPU内，存储微指令，

## 流水线
分为
* 取指
* 译码/取数
* 执行
* 存储器读
* 写回

各个子系统通过数据总线连接形成的数据传送路径称为数据通路，包括程序计数器、算术逻辑运算部件、通用寄存器组、取指部件等，**不包括控制部件**

## IO指令
IO指令实现的数据传送通常发生在**通用寄存器和IO端口之间**，并非IO设备和IO端口

## 中断
* 外部中断请求
* CPU内部异常

## 系统调用过程
1. 传递系统调用参数
2. 执行陷入（trap）指令将用户态转化为内核态，并将返回地址压入堆栈以备后用
3. 执行相应的内核态服务程序
4. 返回用户态

## DMA传输过程
主机向内存写入DMA命令块，向DMA控制器写入该命令块的地址，启动IO设备。然后，CPU继续其他工作，DMA控制器则继续下去直接操作内存总线，将地址放到总线上开始传输。当整个传输完成后，DMA控制器中断CPU

## 奈奎斯特定理和香农定理
### 奈奎斯特定理
在理想低通信道下的最高码元传输速率的公式：
$$C=2W\log_2N \ (b/s)$$
C是信道容量，W是信道带宽，N是信号状态数

奈奎斯特定理适用的情况是无噪声信道，用来计算理论值，在现实中是不存在的

### 香农定理
在噪声与信号独立的高斯白噪信道中，假设信号的功率为S，噪声功率为N，信道通频带宽为W(Hz)，则该信道的信道容量C有：
$$C=W\log_2(1+\frac{S}{N})\ (b/s)$$

S/N和dB的转换：dB=10lg(S/N)

## 802.11数据帧的封装
### IBSS
* 地址1：Destination Address
* 地址2：Source Address
* 地址3：BSSID 
### From AP
* 地址1：Destination Address 
* 地址2：BSSID
* 地址3：Source Address 
### To AP
* 地址1：RA（BSSID） 即AP的IP地址
* 地址2：SA（sourse address）
* 地址3：DA（destination address)
### WDS 
* 地址1：BSSID
* 地址2：Source Address
* 地址3：Destination Address

## RIP,OSPF,BGP运行在那个协议
* RIP运行在UDP
* OSPF运行在IP
* BGP运行在TCP

## 关中断
保护被中断进程现场时关中断，而在执行中断处理程序的时候则是开中断的

## 树的遍历
### 中序遍历
```c
```cpp
void InOrder(BiTree T) {
    if(T!=null){
        InOrder(T->lchild);     //递归遍历左子树
        visit(T);   //访问根结点
        InOrder(T->rchild);     //递归遍历右子树
    }
}
```
先序、后序类似可推，将visit的位置改变即可

## 最小生成树（MST）
最小生成树唯一的充分条件：任意一个环中所包含的边的权值均不相同 