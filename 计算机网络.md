# 基本知识
## 网络协议组成要素
* **语法**
* **语义**
* **同步**

## 通信知识
### 分组交换
#### 传输方式
* 虚电路
* 数据报

#### 时延
##### 类型
* 结点处理时延
* 排队时延
* 传输时延
* 传播时延

##### 计算
$$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$$

##### 存储转发和直接转发的区别
* 存储转发需要收到一个完整的帧再发送，慢
* 直接转发收到数据就发送，快

#### 分组丢失
分组到达速度大于发送速度，分组缓存容量有限，超出容量就会造成丢失

### 电路交换
#### 实现方式
* FDM（频分）
* TDM（时分）
* CDMA（码分）

# 应用层
## 协议数据单元（PDU）
**message**，中文称报文、消息

## 协议
* HTTP(超文本传输协议)
    Web
* FTP(文件传输协议)
    传输文件
* SMTP(简单邮件传输协议)
    传输邮件
* POP3
    查看邮件
* IMAP
    查看邮件
* DNS（域名系统）
    * 查找域名对应的IP地址
        * 迭代查询
        * 递归查询
    * 根DNS服务器
    * 顶级域DNS服务器
    * 权威DNS服务器
    * 本地DNS服务器

# 传输层（运输层）
## 协议数据单元（PDU）
**segment**，中文称报文段、分组、数据段等等
## 协议
### TCP（传输控制协议）
#### TCP报文段结构
* 标志字段
    * **ACK**
    * **SYN**
    * **FIN**
* 序号和确认号
    * TCP提供累积确认

![TCP报文段格式](https://s2.ax1x.com/2019/05/27/VVsBtI.png)
#### 往返时间(RTT)的估计和超时
##### 估计往返时间
新的估计往返时间等于旧的估计往返时间和新的测量时间以一定比例相加
仅在某个时刻做一次测量，且不为重传的报文段测量RTT，只为传送一次的报文段测量
###### 公式
RTT估算：
$$EstimatedRTT(RTT_s)=(1-\alpha)\times EstimatedRTT+\alpha \times SampleRTT$$
α推荐为0.125

RTT变化程度:
$$DevRTT(RTT_D)=(1-\beta)\times DevRTT+\beta\times |SampleRTT-EstimatedRTT|$$

##### 设置重传超时间隔（Karn算法）
$$RTO(TimeoutInteval)=EstimatedRTT+4\times DevRTT$$
如果重传，RTO=2*RTO

#### 功能
##### 可靠数据传输
###### 快速重传
* 接收方
    每收到一个失序报文段，立即发送一个对上一个按序到达报文的重复确认（ACK）
* 发送方
    一旦受到3个冗余ACK，直接重发对方要求的报文段，不过重传计时器依然有效
###### 特点
* 发送和接受窗口不一定一样大
* TCP标准没有规定不按序到达的数据如何处理
* TCP要求接收方必须有累积确认的功能

##### 流量控制
发送方不能淹没接收方缓存

接受窗口rwnd

利用滑动窗口实现流量控制

##### 拥塞控制
###### 和流量控制的区别
拥塞控制针对全网，流量控制针对一对一连接

###### 状态变量
* 拥塞窗口cwnd
* 慢启动阈值ssthresh

###### 拥塞的影响
* 时延变大
* 丢包

###### 方法
* 慢开始和拥塞避免
发送方维持一个叫做拥塞窗口（cwnd）的状态变量。拥塞窗口的大小取决于拥塞程度，动态变化。发送方让发送窗口等于拥塞窗口。开始拥塞窗口的值设置为一个最大报文段（MSS）的数值，记为1。如果没有出现拥塞，每经过一个传输轮次，cwnd变为原来的两倍。为了防止过快增加，设置了慢开始门限状态变量（ssthresh）。当检测到超时时，将ssthresh设为原先cwnd的一半，将cwnd置为1，重新开始慢启动，这个过程中当cwnd的大小等于ssthresh时，执行拥塞避免策略，每次cwnd的大小只增加1.
* 快重传和快恢复
快速重传的策略已经在图中有解释。当发送方接收到3个冗余ACK时（但并没有超时），TCP对于这种事件反应没有超时那么激烈，此时执行快速恢复策略：将ssthresh设为原先cwnd的一半，再将cwnd的值减半，之后每次发送时cwnd的值再增加1。  
一种称为TCP Tahoe的TCP早期版本没有快速恢复策略，不管是超时还是收到3个冗余ACK，均采用慢开始策略。而较新版本的TCP Reno，则综合了快速恢复。两者的区别如下图：
![快速恢复](https://s2.ax1x.com/2019/04/22/EkOay8.png)

#### TCP连接管理
三个阶段
##### 连接建立
###### 1. 三次握手
三次握手的过程：  
* 第一次握手：客户端主机向服务器发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是在报文段的首部中的SYN标志位置为1，代表请求建立连接，称为SYN报文段。客户端随机选择一个初始序号，并将此编号放在SYN报文段的序号字段。该报文段被封装在一个网络层数据报中，发送给服务器。
* 第二次握手：服务器接收到包含SYN报文段的IP数据报，提取出SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的报文段。该报文段也不包含应用层数据，SYN标志位置为1，确认号字段为SYN报文段的编号+1，服务器选择主机的初始序号，并将其放置到TCP报文段首部的序号字段。这个报文段被称为SYNACK报文段。
* 第三次握手：客户端收到SYNACK报文段后，也要给该连接分配缓存和变量。同时再向服务器发送另外一个报文段，对于SYNACK报文段给以确认，这个报文段包含了应用层数据。

三次握手的原因：  
* 双方能确知对方的存在
* 允许双方协商一些参数
* 对运输实体资源进行分配

拓展知识：  
因为第二次握手（还没有正式开始传送数据）时，服务器就已经给TCP连接分配了缓存资源，这为经典的DoS攻击即SYN洪泛攻击（SYN flood attack）提供了环境。在这种攻击中，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段纷至沓来，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽。这种SYN洪泛攻击是被记载的众多DoS攻击中的第一种。

![三次握手过程](https://s2.ax1x.com/2019/05/27/VVs7cT.png)
###### 2. 数据传送

###### 3. 连接释放
连接释放的过程：  
客户端向服务器发送一个特殊的TCP报文段，该报文段FIN标志位置为1。服务器收到后，给发送方回送一个确认报文段。然后服务器发送它自己的终止报文段，其FIN比特被置为1.最后，客户端对服务器的终止报文段进行确认。

![连接释放过程](https://s2.ax1x.com/2019/05/27/VVsT3V.png)

### UDP（用户数据报协议）
#### 无连接的
* 不可靠、失序交付
* 不提供不必要的可靠性扩展（在网络层基础上）

#### UDP报文段结构
![UDP报文段结构](https://s2.ax1x.com/2019/05/27/VVyCjO.png)
#### UDP校验和的计算
发送方的UDP对报文端中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段的校验和字段。举例来说，假定我们有下面3个16比特的字：
```
0110011001100000
0101010101010101
1000111100001100
```
前两个之和是
```
 0110011001100000
+0101010101010101
------------------
 1011101110110101
```
再将上面的和和第三个字相加，得出：
```
 1011101110110101
+1000111100001100
------------------ 
 0100101011000010
```

注意到最后一次加法有溢出，它要被回卷。反码运算就是将所有的0换成1，所有的1换成0.因此，该和`0100101011000010`的反码运算结果是`1011010100111101`，这就是校验和。在接收方，全部的4个16比特字（包括校验和）加在一起，如果该分组中没有引入差错，则显然在接收方处该和将是`1111111111111111`。如果有一个是0，就代表分组中出了差错。

## 传输层和网络层的关系
* 网络层针对主机之间的逻辑通信
* 传输层为主机上的进程提供通信，即端到端的通信，依赖于网络层

对于网络层和传输层的描述，考虑有两个家庭，一家位于辽宁沈阳，一家位于浙江宁波，每家有4口人。每个人每星期要互相写一封信，每封信都用单独的信封通过中国邮政传送。因此每个家庭每星期向另一家发送16封信。每一个家庭有个孩子负责收发邮件，浙江宁波家庭是小明，辽宁沈阳家庭是小红。每星期小红去她的家人那里收集邮件，并将这些信件投到社区的邮筒里。当新建到达沈阳的家庭时，小红也负责将信件分发给家里人。在宁波的小明家里也负责类似的工作。

在这个例子中，邮政服务为两个家庭间提供逻辑通信，邮政服务将信件从一家送到另一家，而不是从一个人送到另一个人。在另一方面，小明和小红为家人之间提供了逻辑通信，他们从家人那里收取信件或到家人那里交付信件。注意到从家人们的角度来看，小明和小红就是邮件服务，尽管他们只是端到端交付的一部分（即端系统部分）。类比关系如下：
```
进程 = 家人
主机（又称为端系统） = 家庭
传输层协议 = 小明和小红
网络层协议 = 邮政服务（包括邮筒）
```
小明和小红都是在自己家里进行工作的，他们没有参与任何一个中间邮件中心对邮件进行分拣，或者将邮件从一个邮件中心送到另一个邮件中心之类的工作。类似地，运输船协议只工作在端系统中。在端系统中，运输船协议将来自应用进程的报文移动到网络边缘（即网络层），反过来也是一样，但对有关这些报文在网络核心如何移动并不作任何规定。

## 多路复用（分用）和多路分解
### 多路复用（发送端）
从不同套接字收集数据块，为每个数据块封装上首部信息生成报文段，传递到网络层

### 多路分解（接收端）
将传输层报文段中的数据交付到正确的套接字，定向给进程

多路复用和多路分解的原理可以同样用上面这个家庭的例子来作类比。每一个家庭成员通过他们的名字来标识（相当于套接字）。当小明从邮递员出收到一批信件，并通过查看收信人名字而将信件交付给他的家人时，他执行的就是一个多路分解操作。当小红从家人那里收集信件并将它们投到邮筒中时，她执行的就是一个多路复用操作。

## 端口
* 熟知端口（0-1023）
 不能随便用
* 登记端口（1023-49151）
 为应用程序长期使用，必须在IANA登记，防止重复
* 客户端口或短暂端口（49152-65535）
 客户进程短暂使用

## 可靠数据传输原理
可靠传输（RDT）的种类
### 信道无错误，无丢失
#### rdt1.0

![rdt1.0](https://s2.ax1x.com/2019/05/27/VV6vSx.png)

### 信道有错误，无丢失
#### rdt2.0（停止等待）
![rdt2.0](https://s2.ax1x.com/2019/05/27/VV6xl6.png)
##### 错误处理方法
发送端重传

##### 新增状态
* 发送端检测
* 接收端校验
    * ACK（肯定确认）
    * NAK（否定确认）

##### 存在缺陷
ACK或NAK出错时，发送方无法得知

#### rdt2.1
![rdt2.1发送方](https://s2.ax1x.com/2019/05/27/VV6z6K.png)
发送方收到含糊不清的ACK或NAK时，重传冗余分组

![rdt2.1接收方](https://s2.ax1x.com/2019/05/27/VVcC0e.png)

接收方需要判定数据是否重复，给每个分组加一个标签代表顺序号

#### rdt2.2
将两次对上个分组的ACK认为是当前分组的NAK

![rdt2.2发送方](https://s2.ax1x.com/2019/05/27/VV6Xf1.png)

![rdt2.2接收方](https://s2.ax1x.com/2019/05/27/VVcSOO.png)

### 信道有错误，有丢失

#### rdt3.0

![rdt3.0](https://s2.ax1x.com/2019/05/27/VVc9mD.png)

设置定时器，超时即重传

采用流水线的方式发送以提高效率
* 增加序号范围
* 发送端需要缓存没确认的分组
* 处理丢失、损坏和超时的分组方法
    * **回退N步（GBN）**
        * 滑动窗口
        * 累积确认
        * 接收端无需缓存
    * **选择重传（SR）**
        * 滑动窗口
        * 接收端需要缓存
        * 发送窗口不能大于接收窗口
        * 序号个数大于等于发送窗口加接收窗口的大小，这样包的序号才不会重复
