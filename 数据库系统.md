
## 数据库设计过程
1. 需求分析
2. 概念设计
    E-R模型设计
3. 逻辑设计
    将E-R模型转化为关系数据库模式
4. 模式求精
5. 物理设计
6. 应用与安全设计

## 数据表的组成
* 关系：一个关系对应一张表
* 元组：表中一行称为一个元组
* 属性：表中一列称为一个属性
* 关系模式：通过关系名和属性名列表对关系进行描述，相当于表的标题和表头

## 数据库系统组成
* 数据库（DB）
* 数据库管理系统（DBMS）
* 数据库应用（DBAP）
* 数据库管理员（DBA）
* 计算机基本系统

## 数据库中的语言
* DDL：数据定义语言
* DML：数据操纵语言
* DCL：数据控制语言。安全保密控制、存储权限控制等

## 模式和数据
模式：对数据库中数据所进行的一种结构性描述，仅仅设计型的描述，不涉及具体的值

视图/数据：某一种表现形式下表现出来的数据库中的数据

## 三级模式
外模式/子模式/用户模式：数据库用户能够看到和处理的局部数据的**结构描述**

逻辑模式/模式/概念模式：从全局角度理解的数据库中全体数据数据的**结构描述**

内模式/存储模式：数据的物理结构和存储方式的描述，含存储路径、存储方式、索引方式等

**三级模式分别对应三级视图，外部视图、概念视图和内部视图**

单说**模式**指的是**概念模式/逻辑模式**，单说**视图**指的是**外部视图/用户视图**

## 两层映像
### 1. 外模式/模式映像（E-C映像）
* 将外模式映射为模式，从而支持实现数据概念视图向外部视图的转换
* **便于用户观察和使用**

### 2. 模式/内模式映像（C-I映像）
* 将模式映射为内模式，从而支持实现数据概念视图向内部视图的转换
* **便于计算机进行存储和处理**

**用户定义三级模式，系统自动实现两层映像**

## 两个独立性
### 1. 逻辑数据独立性
当逻辑模式变化时，可以不改变外模式，只需改变外模式/模式映像，从而无需改变应用程序

### 2. 物理数据独立性
当内部模式变化时，可以不改变逻辑模式，只需改变模式/内模式映像，从而不改变外部模式

## 数据模型
**数据模型**用来描述**模式**，**模式**用来描述**数据**

数据模型由**数据结构**、**数据操作**和**数据完整性约束**3部分组成

数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象

数据模型的例子：
**关系模型**：所有模式都可抽象为表的形式（**数据结构**），每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些**操作**和**约束**

#### 三大数据模型
* 层次模型：**树**的形式组织数据
* 网状模型：**图**的形式组织数据
* 关系模型：**表**的形式组织数据。消除了层次模型和网状模型的指针


## 关系模型
一个关系对应一个表

关系模型就是处理表的，由三个部分组成
* 描述DB各种数据的基本结构形式
* 描述Table与Table之间所可能发生的各种操作（关系运算）
* 描述这些操作所应遵循的约束条件（完整性约束）

### 关系模型的三个要素
* 基本结构：关系/表
* 基本操作：
    基本的：并、差、乘积、选择、投影
    扩展的：交、连接、除
* 完整性约束：实体完整性、参照完整性、用户自定义完整性
### 关系运算
关系运算：关系代数和关系演算

关系演算：元组演算和域演算

关系代数示例：基于集合的运算

元组演算示例：基于逻辑的运算

域演算：基于示例的演算

### 域
表中列的取值范围

一组值的集合，这组值具有相同的数据类型

集合中元素的个数称为域的**基数**

### 笛卡尔积
一组域$D_1,D_2,...,D_n$的笛卡尔积为：
$D_1\times D_2\times ...\times D_n=\{(d_1,d_2,...,d_n)|d_i \in D_i,i=1,...,n\}$

笛卡尔积的每个元素$(d_1,d_2,...,d_n)$称作一个n-元组

元组$(d_1,...,d_n)$的每一个值$d_i$叫做一个**分量**

笛卡尔积是由n个域形成的**所有可能**的n-元组的集合

若$D_i$的基数为$m_i$，则笛卡尔积的**基数**，即元组个数为
$m_1\times m_2\times ...\times m_n$

### 关系
一组域$D_1,D_2,...,D_n$的笛卡尔积的子集

**笛卡尔积中具有某一方面意义的那些元组被称作一个关系**

关系的不同列可能来自同一个域，为区分，需要为每一列起一个名字，该名字即为**属性名**

### 关系模式
关系的描述称为**关系模式**

关系模式通常被简记为$r(U)$或$r(A_1,A_2,...,A_n)$，其中r为关系名，U为属性名的集合，n是关系的**目**或**度**，关系中元组的数目称为关系的**基数**

域名及属性向域的映像常常直接说明为属性的类型、长度

### 关系模式与关系
同一关系模式下，可有很多的关系

关系模式是关系的结构，关系是关系模式在某一时刻的数据

关系模式是稳定的，关系是某一时刻的值，是随时间可能变化的

### 关系的特性
#### 列是同质
每一列中的分量来自同一域，是同一类型的数据

不同的列可以来自同一个域，所以不同的列要给与不同的属性名

#### 关系和行、列的位置无关：
列位置互换性：区分哪一列是靠列名
行位置互换性：区分哪一行是靠某一或某几列的值（关键字/键字/码字）

关系是以内容（名字或值）来区分的，而不是属性在关系的位置来区分

如下面两个关系是完全相同的关系

丈夫|妻子|儿女
----|---|---
李一|王二|张三
赵四|孙五|周六

丈夫|儿女|妻子
----|---|---
赵四|周六|孙五
李一|张三|王二

#### 不能完全相同
理论上，**关系**的任意两个元组不能完全相同（集合的要求）

现实应用中，**表**可能并不完全遵守此特性

#### 属性不可再分
属性不可再分特性：又被称为关系**第一范式**

### 关系上的一些重要概念
#### 超码
能唯一标识一个元组的属性集
#### 候选码
最小的超码
##### 主属性和非主属性
包含在任何一个候选码中的属性称作主属性

其他属性称作非主属性

最极端的：所有属性构成这个关系的候选码，称为**全码**关系

#### 主码
用户选定候选码的其中一个作为主码

DBMS以**主码**为主要线索管理关系中的各个元组

#### 外码
关系R中的一个属性组，是另一个关系S的主码，这个属性组称为R的**外码**

两个关系通常是靠**外码**连接起来的

### 关系模型的完整性
#### 1. 实体完整性
关系的主码中的属性值不能为空值

空值：不知道、不存在或无意义的值

#### 2. 参照完整性
若关系r的外码F参照关系s的主码，则关系r中的每一个元组在属性F上的取值，要么为空值null，要么等于关系s中某个元组的主码值

#### 3. 用户自定义完整性
用户针对具体的应用环境定义的完整性约束条件

## 关系代数
基本思维：一个集合，施加一个操作得到一个集合，一次施加关系代数操作，进而得到所需结果。以集合为中心

两类操作
1. 集合操作：
    * 并
    * 交
    * 差
    * 笛卡尔积
2. 纯关系操作
    * 投影
    * 选择
    * 连接
    * 除

### 并相容性
并、差、交等，需满足并相容性

定义：
R与S存在相容性，当且仅当
1. 关系R和关系S的属性数目相同
2. 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同

### 并
记作$R\cup S$，它由或者出现在关系R中，或者出现在S中的元组构成

数学描述：$R\cup S=\{t|t\in R\lor t\in S\}$

将两个关系的元组合并成一个关系，在合并时去掉重复的元组

### 差
记作R-S，由出现在R中但不出现在S中的元组构成

数学描述：$R-S=\{t|t\in R\land t\notin S\}$

### 笛卡尔积
由关系R中的元组与关系S的元组进行所有可能的拼接构成

### 选择
给定一个关系R，同时给定一个选择的条件con，选择运算结果也是一个关系，记作$\sigma_{con} (R)$，它从关系R中选择出满足给定条件con的元组构成

数学描述：$\sigma_{con}(R)=\{t|t\in R\land con(t)='真'\}$

### 投影
给定一个关系R，A为R的属性集，从关系R中选出属性包含在A中的列构成，记作$\Pi_A(R)$

如果投影后有重复元组，应该**去除**

### 交
假设关系R与S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作$R\cap S$

交运算可以通过差运算来实现
$R\cap S=R-(R-S)=S-(S-R)$

### $\theta$-连接
涉及多个表之间的操作

从关系r和关系s的笛卡尔积中，选取r关系中属性A与S中属性B之间满足$\theta$条件的所有元组

数学描述
$r\bowtie_{\theta}s=\sigma_\theta(r\times s)$

#### 等值连接
$\theta$为等值比较谓词的连接运算
##### 自然连接
一种特殊的等值连接，要求两个参与连接的关系具有公共的属性集，即$R\cap S\neq \empty$，并在这个公共属性集上进行等值连接；同时，还要求将连接结果中的重复属性列去除掉，即在公共属性集中的列只保留一次（**$\theta$连接不去除重复列**）

R:
A|B
-|-
a|1

S:
B|C
-|-
1|x

$R\times S$
A|B|B|C
-|-|-|-
a|1|1|x

$R\bowtie S$
A|B|C
-|-|-
a|1|x

### 除
用于求解“查询全部的、所有的”问题

前提条件：给定关系$R(A_1,A_2,...,A_n)$为n度关系，关系$S(B_1,B_2,...,B_m)$为m度关系。当且仅当：属性集$\{B_1,...,B_m\}$是属性集$\{A_1,...,A_m\}$的真子集时，可以进行关系R与关系S的除运算

$R\div S$的结果关系是k=m-n度关系，由$\{C_1,...,C_m\}$属性构成

$R\div S$的元组和S中的每一个元组相组合构成的新元组，都得在R当中

数学描述：
$R\div S=\{t|t\in\Pi_{R-S}(R)\land\forall u\in S(tu\in R)\}$

### 外连接
把不能连接的元组也保留到结果关系中，如关系r中不能连接的元组在结果元组中的关系s的属性上可以全部置为空值null

只把左关系中不能连接的元组保留到结果关系中，则称为**左外连接**，反正称为**右外连接**，左右都保留称为**全外连接**

## SQL
集DDL,DML和DCL于一体的数据库语言

DDL语句引导词：create（建立）,alter（修改）,drop（撤销）

DML语句引导词：insert,delete,update,select

DCL语句引导词：grant,revoke
授权和撤销授权

### DDL
#### 创建数据库
```sql
create database 数据库名
```

#### 创建表
```sql
create table 表名（列名 数据类型[Primary key|Unique][Not null][,列名 数据类型[Not null],...])
```
Primary key：主码约束。每个表只能创建一个主码约束。

Unique：唯一性约束（即候选键）。可以有多个唯一性约束

Not null：非空约束。是指该列允许不允许有空值出现

示例：
定义学生表Student
```sql
create table Student(S# char(8) not null,Sname char(10),Ssex char(2), Sage integer,D# char(2),Sclass char(6))
```

#### 修正数据库
修正数据库的定义，主要是修正表的定义
``` sql
alter table tablename
[add {colname datatype,...}]    #增加新列
[drop {完整性约束名}]   #删除完整性约束
[modify {colname datatype,...}] #修改列定义
```
#### 撤销基本表
drop table 表名

delete语句只是删除表中的元组，而drop语句是撤销包含表格式、表中所有元组、由该表导出的视图等相关的所有内容

#### 撤销数据库
drop database 数据库名

### DML
#### 向表中追加元组
```sql
insert into 表名[(列名[,列名]...)] values (值[,值],...)
```

示例，追加学生表中的元组
```sql
insert into student(S#,Sname,Ssex,Sage,D#,Sclass)
values('9803','张四','女',20,'03','98')
```

#### 简单单表查询
select - from - where

默认select是有重复元组的，select distinct可以去重

#### 检索结果排序
select - from -where - order by

order by 列名 [asc|desc]

#### 模糊查询
select - from - where like

列名 [not] like '字符串'
给定字符串中可以出现匹配符

匹配规则：
%:匹配零个或多个字符
_:匹配任意单个字符
\:转义字符

#### 多表联合查询
通过广义笛卡尔积后再进行选择运算来实现
```sql
select 列名 [[,列名]...]
from 表名1,表名2,...
where 检索条件
```
相当于$\Pi_{列名,...,列名}(\sigma_{检索条件}(表名1\times 表名2\times ...))$

检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种$\theta$-连接

如果连接的两个表重名，as可以用来给表起别名。as也可以用来给列起别名

#### 批量数据新增
```sql
insert into 表名 [(列名[,列名]...)]
子查询
```

#### 删除命令
```sql
delete from 表名
[where 条件表达式]
```
如果where条件省略，则删除所有的元组

#### 更新命令
```sql
update 表名
set 列名=表达式|（子查询）
[where 条件表达式]
```
如果where条件省略，则更新所有的元组

### 子查询
#### （Not）IN
表达式 [not] in (子查询)

#### 非相关子查询和相关子查询
带有子查询的语句区分为外层查询和外层查询

**非相关子查询**：内层查询独立进行，没有涉及任何外层查询相关信息的子查询

**相关子查询**：内层查询需要依靠外层查询的变量
外层向内层传递的参量需要使用外层的表名或表别名来限定

相关子查询只能由外层向内层传递参数，而不能反之；这也成为变量的作用域原则

#### $\theta$-some/$\theta$-all子查询

表达式 $\theta$ some (子查询)
表达式 $\theta$ all (子查询)


$\theta$是比较运算符：<,>,>=,<=,=,<>

表达式的值与子查询结果的某一个值相比较满足$\theta$关系，则用some
表达式的值与子查询结果的所有值相比较满足$\theta$关系，则用all

##### 等价性变换
如下两种表达方式含义是相同的
```sql
表达式 = some (子查询)
表达式 in (子查询)
```

```sql
表达式 not in (子查询)
表达式 <> all (子查询)
```

#### (not)exists 子查询
子查询结果中有无元组存在

不加not的exists可以不同

not exists更有用，可以查询所有、全部的情况，相当于关系代数中的除运算

示例：检索学过001号老师主讲的所有课程的所有同学的姓名
```sql
select Sname from Student
where not exists # 不存在
    (select * from Course   // 有一门001教师主讲课程
    where Course.T#='001' and not exists    // 该同学没学过
        (select * from SC
        where S#=Student.S# and C#=Course.C#))
```

### 结果计算
可以计算两个属性的差、和、乘积等

### 聚集函数
五个内置聚集函数：
* count
* sum
* avg
* max
* min

#### 分组查询
求每一门课程的平均成绩

```sql
select 列名
from 表名
[where 检索条件]
[group by 分组条件]
```

分组条件可以是
列名1，列名2，...
##### 分组过滤
```sql
select 列名
from 表名
[where 检索条件]
[group by 分组条件 [having 分组过滤条件]]
```

### 并-交-差
并运算：union，交运算：intersect，差运算：except
```sql
子查询 {union [all]|intersect [all]|except [all] 子查询}
```
通常情况下自动删除重复元组，相当于集合操作：不带ALL。若要保留重复的元组，则要带ALL

假设子查询1的一个元组出现m次，子查询2的一个元组出门n次，则结果为
union all 出现m+n次
intersect all 出现min(m,n)次
except all 出现max(0,m-n)次

### 空值的处理
is [not] null

null值参与算术运算，则该算术运算的值为null

null值参与比较运算，结果可视为false

null值参与聚集运算，除count(*)之外，其他聚集函数都忽略null

### 连接运算
表1 join 表2 {on 连接条件|using (colname)}

inner join：$\theta$-连接

left outer join,right outer join,full outer join：外连接

natural join：自然连接，公共属性只出现一次（很多DBMS不支持）

### 视图
对应逻辑模式的数据在SQL中被称为**基本表**，对应外模式的数据称为**视图**。视图不仅包含外模式，而且包含其外模式/模式映像

视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。当基本表中的数据发生变化时，从视图中查询出的数据也随之改变

视图的主要作用：
1. 简化用户的操作
2. 使用户能以多种角度看待同一数据
3. 对重构数据库提供了一定程度的逻辑独立性
4. 能够对机密数据提供安全保护
5. 适当地利用视图可以更清晰地表达查询

#### 定义视图
```sql
create view view_name [(列名,..)]
as 子查询 [with check option]
```

#### 更新视图
```sql
update 视图名
set ...
[where]
```
对视图数据的更改最终要反映到对基本表的更改上。

如果视图的定义中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作

#### 撤销视图
```sql
drop view 视图名
```

## 数据库完整性
* **关系约束/表约束**：对若干元组间、关系集合上以及关系之间的联系的约束
* **列约束**：对列的类型、取值范围、精度、是否允许控制等的约束条件
* **元组约束**：元组中属性间的联系的约束

### 列约束
```sql
{NOT NULL|
    [CONSTRAINT constraintname]
        {UNIQUE
        |PRIMARY KEY    # 主键
        |CHECK(search_cond) # 列值满足用户自定义条件
        |FOREIGN KEY(colname) REFERENCES tablename[(colname)]   # 外键
            [ON DELETE {CASCADE|SET NULL}]
        }
}
```
只能应用在单一列上，后面的约束只能是单一列非空、单一列唯一、单一列为主键或单一列相关

### 关系约束
对多列或元组的值进行约束
```sql
[CONSTRAINT constraintname]
    {UNIQUE
    |PRIMARY KEY    # 主键
    |CHECK(search_cond) # 列值满足用户自定义条件
    |FOREIGN KEY(colname) REFERENCES tablename[(colname)]   # 外键
        [ON DELETE {CASCADE|SET NULL}]
    }
```

create table中定义的表约束或列约束可以在之后撤销或追加。撤销或追加约束的语句是alter table
```sql
alter table tablename
    add colname 列约束条件,    #新增一列
    drop column columnname, #删除一列
    modify columnname data-type 列约束条件, #修改一列
    add constraint constrain_name,   #新增一个表约束条件
    drop constraint constraint_name,    #删除一个表约束条件
    drop primary key    #删除主码约束
```
### 实体完整性
单个属性的主码定义，可以定义为列级约束，也可以定义为表级约束

列约束定义示例
```sql
create table class(
    classNo char(6) not null primary key,
    ...
)
```

关系约束定义示例
```sql
create table class(
    classNo char(6) not null,
    constraint ClassPK primary key (classNo)
)
```

多个属性的主码定义只能定义为关系约束，主码定义可以不写约束名

```sql
create table sc(
    studentNo char(6) not null,
    courseNo char(3) not null,
    PRIMARY KEY(studentNo,courseNo)
)
或者
create table sc(
    studentNo char(6) not null,
    courseNo char(3) not null,
    CONSTRAINT scPK PRIMARY KEY(studentNo,courseNo)
)
```

### 触发器
用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活
```sql
CREATE TRIGGER triggerName
ON tableName
FOR {INSERT|UPDATE|DELETE}
AS SQL语句
```

## 数据库安全性
### DBMS的安全机制
* 自主存取控制
* 强制存取控制

### 自主存取控制
* 授权者：决定用户权利的人
* 授权：授予用户访问的权利

访问规则通常存放在**数据字典**中

自助存取控制通过SQL的GRANT和REVOKE语句实现

```sql
GRANT {all|<command_list>} TO {public|<username_list>}
REVOKE {all|<command_list>} FROM {public|<username_list>}
```

## 游标
对SELECT语句返回的结果值进行逐行处理。可对游标的当前位置进行更新、查询和删除