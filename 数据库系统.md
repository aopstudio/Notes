
## 数据库设计过程
1. 需求分析
2. 概念设计
    E-R模型设计
3. 逻辑设计
    将E-R模型转化为关系数据库模式
4. 模式求精
5. 物理设计
6. 应用与安全设计

## 数据表的组成
* 关系：一个关系对应一张表
* 元组：表中一行称为一个元组
* 属性：表中一列称为一个属性
* 关系模式：通过关系名和属性名列表对关系进行描述，相当于表的标题和表头

## 数据库系统组成
* 数据库（DB）
* 数据库管理系统（DBMS）
* 数据库应用（DBAP）
* 数据库管理员（DBA）
* 计算机基本系统

## 数据库中的语言
* DDL：数据定义语言
* DML：数据操纵语言
* DCL：数据控制语言。安全保密控制、存储权限控制等

## 模式和数据
模式：对数据库中数据所进行的一种结构性描述，仅仅设计型的描述，不涉及具体的值

视图/数据：某一种表现形式下表现出来的数据库中的数据

## 三级模式
外模式/子模式/用户模式：数据库用户能够看到和处理的局部数据的**结构描述**

逻辑模式/模式/概念模式：从全局角度理解的数据库中全体数据数据的**结构描述**

内模式/存储模式：数据的物理结构和存储方式的描述，含存储路径、存储方式、索引方式等

**三级模式分别对应三级视图，外部视图、概念视图和内部视图**

单说**模式**指的是**概念模式/逻辑模式**，单说**视图**指的是**外部视图/用户视图**

## 两层映像
### 1. 外模式/模式映像（E-C映像）
* 将外模式映射为模式，从而支持实现数据概念视图向外部视图的转换
* **便于用户观察和使用**

### 2. 模式/内模式映像（C-I映像）
* 将模式映射为内模式，从而支持实现数据概念视图向内部视图的转换
* **便于计算机进行存储和处理**

**用户定义三级模式，系统自动实现两层映像**

## 两个独立性
### 1. 逻辑数据独立性
当逻辑模式变化时，可以不改变外模式，只需改变外模式/模式映像，从而无需改变应用程序

### 2. 物理数据独立性
当内部模式变化时，可以不改变逻辑模式，只需改变模式/内模式映像，从而不改变外部模式

## 数据模型
**数据模型**用来描述**模式**，**模式**用来描述**数据**

数据模型由**数据结构**、**数据操作**和**数据完整性约束**3部分组成

数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象

数据模型的例子：
**关系模型**：所有模式都可抽象为表的形式（**数据结构**），每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些**操作**和**约束**

#### 三大数据模型
* 层次模型：**树**的形式组织数据
* 网状模型：**图**的形式组织数据
* 关系模型：**表**的形式组织数据。消除了层次模型和网状模型的指针


## 关系模型
一个关系对应一个表

关系模型就是处理表的，由三个部分组成
* 描述DB各种数据的基本结构形式
* 描述Table与Table之间所可能发生的各种操作（关系运算）
* 描述这些操作所应遵循的约束条件（完整性约束）

### 关系模型的三个要素
* 基本结构：关系/表
* 基本操作：
    基本的：并、差、乘积、选择、投影
    扩展的：交、连接、除
* 完整性约束：实体完整性、参照完整性、用户自定义完整性
### 关系运算
关系运算：关系代数和关系演算

关系演算：元组演算和域演算

关系代数示例：基于集合的运算

元组演算示例：基于逻辑的运算

域演算：基于示例的演算

### 域
表中列的取值范围

一组值的集合，这组值具有相同的数据类型

集合中元素的个数称为域的**基数**

### 笛卡尔积
一组域$D_1,D_2,...,D_n$的笛卡尔积为：
$D_1\times D_2\times ...\times D_n=\{(d_1,d_2,...,d_n)|d_i \in D_i,i=1,...,n\}$

笛卡尔积的每个元素$(d_1,d_2,...,d_n)$称作一个n-元组

元组$(d_1,...,d_n)$的每一个值$d_i$叫做一个**分量**

笛卡尔积是由n个域形成的**所有可能**的n-元组的集合

若$D_i$的基数为$m_i$，则笛卡尔积的**基数**，即元组个数为
$m_1\times m_2\times ...\times m_n$

### 关系
一组域$D_1,D_2,...,D_n$的笛卡尔积的子集

**笛卡尔积中具有某一方面意义的那些元组被称作一个关系**

关系的不同列可能来自同一个域，为区分，需要为每一列起一个名字，该名字即为**属性名**

### 关系模式
关系的描述称为**关系模式**

关系模式通常被简记为$r(U)$或$r(A_1,A_2,...,A_n)$，其中r为关系名，U为属性名的集合，n是关系的**目**或**度**，关系中元组的数目称为关系的**基数**

域名及属性向域的映像常常直接说明为属性的类型、长度

### 关系模式与关系
同一关系模式下，可有很多的关系

关系模式是关系的结构，关系是关系模式在某一时刻的数据

关系模式是稳定的，关系是某一时刻的值，是随时间可能变化的

### 关系的特性
#### 列是同质
每一列中的分量来自同一域，是同一类型的数据

不同的列可以来自同一个域，所以不同的列要给与不同的属性名

#### 关系和行、列的位置无关：
列位置互换性：区分哪一列是靠列名
行位置互换性：区分哪一行是靠某一或某几列的值（关键字/键字/码字）

关系是以内容（名字或值）来区分的，而不是属性在关系的位置来区分

如下面两个关系是完全相同的关系

丈夫|妻子|儿女
----|---|---
李一|王二|张三
赵四|孙五|周六

丈夫|儿女|妻子
----|---|---
赵四|周六|孙五
李一|张三|王二

#### 不能完全相同
理论上，**关系**的任意两个元组不能完全相同（集合的要求）

现实应用中，**表**可能并不完全遵守此特性

#### 属性不可再分
属性不可再分特性：又被称为关系**第一范式**

### 关系上的一些重要概念
#### 超码
能唯一标识一个元组的属性集
#### 候选码
最小的超码
##### 主属性和非主属性
包含在任何一个候选码中的属性称作主属性

其他属性称作非主属性

最极端的：所有属性构成这个关系的候选码，称为**全码**关系

#### 主码
用户选定候选码的其中一个作为主码

DBMS以**主码**为主要线索管理关系中的各个元组

#### 外码
关系R中的一个属性组，是另一个关系S的主码，这个属性组称为R的**外码**

两个关系通常是靠**外码**连接起来的

### 关系模型的完整性
#### 1. 实体完整性
关系的主码中的属性值不能为空值

空值：不知道、不存在或无意义的值

#### 2. 参照完整性
若关系r的外码F参照关系s的主码，则关系r中的每一个元组在属性F上的取值，要么为空值null，要么等于关系s中某个元组的主码值

#### 3. 用户自定义完整性
用户针对具体的应用环境定义的完整性约束条件

## 关系代数
基本思维：一个集合，施加一个操作得到一个集合，一次施加关系代数操作，进而得到所需结果。以集合为中心

两类操作
1. 集合操作：
    * 并
    * 交
    * 差
    * 笛卡尔积
2. 纯关系操作
    * 投影
    * 选择
    * 连接
    * 除

### 并相容性
并、差、交等，需满足并相容性

定义：
R与S存在相容性，当且仅当
1. 关系R和关系S的属性数目相同
2. 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同

### 并
记作$R\cup S$，它由或者出现在关系R中，或者出现在S中的元组构成

数学描述：$R\cup S=\{t|t\in R\lor t\in S\}$

将两个关系的元组合并成一个关系，在合并时去掉重复的元组

### 差
记作R-S，由出现在R中但不出现在S中的元组构成

数学描述：$R-S=\{t|t\in R\land t\notin S\}$

### 笛卡尔积
由关系R中的元组与关系S的元组进行所有可能的拼接构成

### 选择
给定一个关系R，同时给定一个选择的条件con，选择运算结果也是一个关系，记作$\sigma_{con} (R)$，它从关系R中选择出满足给定条件con的元组构成

数学描述：$\sigma_{con}(R)=\{t|t\in R\land con(t)='真'\}$

### 投影
给定一个关系R，A为R的属性集，从关系R中选出属性包含在A中的列构成，记作$\Pi_A(R)$

如果投影后有重复元组，应该**去除**

### 交
假设关系R与S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作$R\cap S$

交运算可以通过差运算来实现
$R\cap S=R-(R-S)=S-(S-R)$

### $\theta$-连接
涉及多个表之间的操作

从关系r和关系s的笛卡尔积中，选取r关系中属性A与S中属性B之间满足$\theta$条件的所有元组

数学描述
$r\bowtie_{\theta}s=\sigma_\theta(r\times s)$

#### 等值连接
$\theta$为等值比较谓词的连接运算
##### 自然连接
一种特殊的等值连接，要求两个参与连接的关系具有公共的属性集，即$R\cap S\neq \empty$，并在这个公共属性集上进行等值连接；同时，还要求将连接结果中的重复属性列去除掉，即在公共属性集中的列只保留一次（**$\theta$连接不去除重复列**）

R:
A|B
-|-
a|1

S:
B|C
-|-
1|x

$R\times S$
A|B|B|C
-|-|-|-
a|1|1|x

$R\bowtie S$
A|B|C
-|-|-
a|1|x

### 除
用于求解“查询全部的、所有的”问题

前提条件：给定关系$R(A_1,A_2,...,A_n)$为n度关系，关系$S(B_1,B_2,...,B_m)$为m度关系。当且仅当：属性集$\{B_1,...,B_m\}$是属性集$\{A_1,...,A_m\}$的真子集时，可以进行关系R与关系S的除运算

$R\div S$的结果关系是k=m-n度关系，由$\{C_1,...,C_m\}$属性构成

$R\div S$的元组和S中的每一个元组相组合构成的新元组，都得在R当中

数学描述：
$R\div S=\{t|t\in\Pi_{R-S}(R)\land\forall u\in S(tu\in R)\}$

### 外连接
把不能连接的元组也保留到结果关系中，如关系r中不能连接的元组在结果元组中的关系s的属性上可以全部置为空值null

只把左关系中不能连接的元组保留到结果关系中，则称为**左外连接**，反正称为**右外连接**，左右都保留称为**全外连接**

## SQL
集DDL,DML和DCL于一体的数据库语言

DDL语句引导词：create（建立）,alter（修改）,drop（撤销）

DML语句引导词：insert,delete,update,select

DCL语句引导词：grant,revoke
授权和撤销授权

### DDL
#### 创建数据库
create database 数据库名

#### 创建表
create table 表名（列名 数据类型[Primary key|Unique][Not null][,列名 数据类型[Not null],...])

Primary key：主码约束。每个表只能创建一个主码约束。

Unique：唯一性约束（即候选键）。可以有多个唯一性约束

Not null：非空约束。是指该列允许不允许有空值出现

示例：
定义学生表Student
```sql
create table Student(S# char(8) not null,Sname char(10),Ssex char(2), Sage integer,D# char(2),Sclass char(6))
```

### DML
#### 向表中追加元组
```sql
insert into 表名[(列名[,列名]...)] values (值[,值],...)
```

示例，追加学生表中的元组
```sql
insert into student(S#,Sname,Ssex,Sage,D#,Sclass)
values('9803','张四','女',20,'03','98')
```