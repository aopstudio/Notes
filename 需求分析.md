# Chapter 1 介绍 
## 软件开发的战略性技术
1. 需求工程
2. 项目管理
3. 软件体系结构设计

## 项目的成功标志
在规定的时间内，在规定的成本条件下，达到或超过项目利益干系人的需求

<!-- 此处应有图-->

## 软件开发的本质
1. 复杂性
2. 一致性
3. 可变性
4. 不可见性

## 软件开发的偶然性因素
1. 利益干系人
2. 过程
3. 建模、模型

### 利益干系人
客户 投资人 老板 用户 开发人员 竞争对手 项目管理人员 政府 开发人员家属……
### 过程
1. 顺序
2. 成果物
3. 分配人
4. 标准
## 软件开发模式
1. 瀑布式
2. 敏捷
3. 增量迭代
4. RUP
## 开发方法（技术
1. 面向对象
2. 面向功能（结构化）
3. 面向数据
### 面向对象和结构化方法的区别
1. 分解方法
    a. 功能
    b. 对象
2. 代码层面
3. 开发方式
    以五子棋为例
    * 结构化：
        1. 开始
        2. 黑子先行
        3. 绘制棋盘
        4. 判断输赢
        5. 轮到白子
        6. 绘制棋盘
        7. 判断输赢
        8. 返回步骤2.
        9. 输出结果
    
    * 面向对象：
        1. 棋子
            移动
            ……
        2. 棋盘
            绘制
        3. 规则系统（由配置文件决定）
            判断输赢


## 回顾
1. **软件开发的战略性技术**
2. 软件开发的本质
3. 软件开发的偶然性因素
    1. 利益干系人
        * 用户侧
        * 开发侧
    2. 过程模型<通用模型>
        * 顺序
        * 时间 成果物
        * 分配人
        * 标准
    3. 建模
        UML语言 对象描述语言
4. *面向对象和结构化区别*

## 系统规划
* efficiency强调效率 更快地朝目标前进 正确地做事 “方法论”
* effectiveness强调效能 确保向目标前进 做正确的事

企业上层人员需要effectiveness,企业基层人员需要efficiency
## SWOT approach
**strengths weakness opportunities threats**
* 任务目标
    * 内部分析
        * 优势
        * 弱点
    * 外部分析
        * 机会
        * 威胁

## 系统类型
* OLTP（事务处理）
* OLAP（分析）

## 软件开发生命周期

1. 建模方法
2. 阶段划分
3. 开发方法和开发模式

**阶段不可跨越，但阶段成果物可以省略**
### 生命周期
1. 需求分析
    * 功能性需求和非功能性需求
2. 系统设计
    * 架构设计
    * 细节设计
3. 实现
    * 编码
    * round-trip engineering 往返工程
4. 集成和部署
5. 运作和维护
## 省略成果物的影响
* 只能参照代码做测试
* 隐藏了问题
* 只能不断修改代码

<!--此处应有V型模型图-->


## 本章小结
1. **软件开发的战略性技术**
2. 软件开发的偶然性因素
3. 过程模型（方法论）
4. 面向对象和结构化区别
5. 软件开发的生命周期

# Chapter 2 需求分析
## 软件开发的第一步
* 需求确定
* 需求调研
* 需求获取
## 需求获取的重要性
1. 最困难
2. 最关键
3. 最易出错
4. 最需要交流
### 最困难
#### 需求获取是否准确的前提条件
1. 领域知识（行业）
2. 沟通能力
#### 复合型人才
1. 业务与技术
2. 管理与技术
3. 外语与技术
4. 文学与技术
5. 销售与技术
## 什么是IT解决方案（方法论）
1. 商业解决方案（业务 商业模式）
2. 实现业务流程（业务场景）
3. 触发业务流程改进
4. IT基础架构
5. 形成商品和产品
## 什么是需求
提出的事物及其品质要求
**谁需要什么样的东西**
三位一体
* 谁：需求主体（最终用户）
* 什么样的：需求的形式（样式 布局 颜色 交互）
* 东西：需求的内容（数据 信息）
## 需求的种类
* 功能需求
* 非功能需求
    * 质量要求
        * 扩展性
        * 灵活性
        * 可靠性
        * 性能
        * ……
    * 约束
例子：ATM机
1. 能验证卡的有效性——功能需求
2. 3秒内验证用户身份——非功能需求
3. 限制每天取款不超过1万元——功能需求
4. 使用C++实现——肺功能需求
## 系统软件架构
由非功能需求决定
## 需求层次
* 业务需求：业务目标（系统目标）——行动力、指导性（纲领性—）
* 用户需求：用户期望系统实现的功能——这里的**功能**是指完成的事情
* 功能需求：软件开发人员应实现的功能——这里的**功能**是指功能点
* 技术需求：技术细节
## 变更的频度
*从上到下，变更产生影响逐渐变大，变更频度逐渐变小*
* 呈现样式
* 展现逻辑
* 业务逻辑
* 业务流程
* 数据结构
## 需求层次细说
* 业务需求、用户需求：用户侧，只要用户说的就是，不管多细
* 功能需求、技术需求：软件开发侧
**需求分析就是从用户侧需求分析得到软件开发侧需求的过程**
## 需求获取总体流程
### 前提条件
* 领域知识
* 沟通能力
### 具体流程
1. 组织队伍
2. 确定需求调研计划和调研问题
3. 发给用户方确认
4. 组织实施需求调研工作（需要采用需求获取技术）
5. 整理和确认调研结果
## 需求获取技术
1. 访谈 面对面交流（2~4人）
    风险：获取障碍，人的情绪会影响
2. 问卷调查 问题设计
    问题类型
    1. 封闭性（一般疑问句）
        确认
    2. 开放性 5W 1H
        who where why when what how
    
    一般选择半封闭性的问题

    步骤    
    1. 目的 目标
    2. 设计
    3. 小范围实验
    4. 修改完善
    5. 发出/收集/整理
3. 观察/示范 （风险：做样子）
    要有同理心 要使最终用户感到友好和易用
4. 文档研究 （风险：文档可能过时，不符合实际情况）
    文档指
    1. 行业标准、国家国际标准
    2. 规章制度
    3. 工作流程（操作手册）
    4. 各类报表、报告、表格
5. 文档
    会前：
    1. 会议计划 目的
    2. 准备会议材料
    3. 发送给与会人员

    会中
    1. 时长1.5h左右
    2. 设立会议主席控制进程
    3. 确定发言时长

    会后：
    1. 整理会议记录
    2. 形成会议纪要
6. 原型法
    方法：
    1. 纸/笔
    2. 画图工具
    3. 原型开发工具
    4. HTML+CSS
7. 头脑风暴
## 需求获取的主要工作
1. **相关人员分析**
相关人员即直接或间接从系统中受益的人
针对具体的人确定具体的问题
将业务需求和用户需求获取完善、准确
2. **针对性的问题提纲**
    * 问题类型
    1. 宏观（全局）
    2. 中观（局部）
    3. 微观（细节）
    


## 将子系统行为分配给子系统元素
* 具体步骤
    * 对于每个接口，决定参与接口实现的类或子系统必要时需要创建新的类以及子系统
    * 让类和子系统交互来完成接口定义的行为，需要结合框架机制

子系统元素类型
1. 负责通信的类
2. 负责算法、业务逻辑的类
3. 负责数据
4. 辅助类、基础类
## 记录子系统元素
具体工作
* 描述类和子系统的责任
* 确定类和子系统的属性和关系
* 整合类和子系统

记录子系统的内部结构，要用一个或多个类图

设计模型
1. 类的交互模型（时序图）
2. **设计类图**

### 详细设计 设计类图
1. 类名、可见性、职责
2. 属性（与生俱来）
    可见性、类型初始值
3. 方法名、出参、入参
    职责、功能
    伪代码

软件公司（解决方案）定制化
1. **项目经理**
2. 需求分析（咨询顾问）
3. 架构师（懂业务）

# 设计原则与模式

**自底向上**
* 面向对象思想 公理
* GRASP设计原则 定理
* 高级设计原则（SRP） 推论
* 设计模式（GOF） 定式
* 组件（AOP） 应用

下面三层不会改变
## 高级设计原则
* OCP（开放-封闭原则）
* SRP（单一职责原则）
* LSP（里氏替换原则）
* DIP（依赖倒置原则）
* ISP

### OCP
* 类模块应该是可扩展的，不可修改的
* 对扩展开放，对更改封闭
* 在设计一个模块时，这个模块可以在不被修改的前提下被扩展

优点：
所有的软件系统都有一个共同的性质，需求都会随时间的推移而发生变化。在软件系统面临新的需求时，系统的设计必须是稳定的。

如何在OO中引入OCP
* 不允许更改的是系统的抽象层，允许扩展的是系统的实现层
* 把对实体的依赖改为对抽象的依赖

对OCP的追求适可而止，不要陷入过度设计

### SRP
* 违反SRP通常由于过于真实地设计了一个类
* 往更高一层进行抽象化提取，将对某个类的依赖改变为对一组接口或抽象类的依赖

### LSP
同一个继承体系中的对象应该有共同的行为特征

继承且覆盖超类方法时，子类方法的可见性必须大于等于超类方法的可见性，子类方法所抛出的受检查异常智能是超类中对应的方法所抛出的受检查异常的子类

如果违反了LSP
城建一个新的抽象类C
### DIP
高层模块不应该依赖于低层模块。二者都应该依赖于抽象。

## 三个基本面向对象设计原则
* 针对接口编程，不是针对实现编程
* 优先使用对象组合，而不是类继承
* 封装变化点

## 如何设计好的面向对象

# Chapter 7 GUI Design

## UI UE
1. 布局
2. 风格（颜色、对比）
3. 字体
4. 图书
5. 图标

### 人文学科
1. 文学
2. 沟通能力
3. 管理学

## UE
1. 交互、过程
2. 人体工学

## 架构师角色
1. 半技术专家
2. 半文学家
3. 半政治家
4. 半导师
5. 半传教士


Server solutions make the software
Client solutions sell the software

PC端：微软
B/S端：模仿

# Chapter 8 持久化和数据库
## 数据库类型
1. 关系型数据库
2. 对象型数据库
3. 对象关系型数据库

## 数据模型的层次
1. 概念数据模型 
E-R模型
概念模型（实体类）
2. 数据库逻辑模型 
表结构
3. 物理数据模型
a.与具体的数据库有关
b.存储
c.硬盘

## 参照完整性
1. Upd(R) Del(R)
2. Upd(C) Del(C)
3. Upd(N) Del(N)
4. Upd(D) Del(D)

第一种：只有当子表数据都删除之后才能删除
第二种：删除父表时删除所有相关的子表数据
第三种：子表项相关数据设为null
第四种：子表项相关数据设为默认

最常用的组合是Upd(C) Del(R) 

1. 存储过程
2. SQL语句

存储过程运行速度快
但无法跨平台执行

应用表用view
基础表用table

视图对基础表起到了封装性的作用，数据库底层改了程序不需要大改

### 对象映射
对象属性是集合
### 对象关联关系的映射
1. 多重性的方向
2. 多对多关系的映射
### 聚合关系的映射
### 继承关系的映射

# 第一讲
1. 软件的本质
2. 软件开发的偶然性因素
    * 利益干系人
    * 过程
    * 模型
3. 软件开发的生命周期
4. 过程模型
    * CMMI
    * ISO 9000
5. 面向对象和结构化区别
6. 面向对象分析/设计
# 第二讲
1. 什么是需求
2. 需求种类
3. 需求层次
4. 需求获取重要性
5. 需求获取的步骤和流程
6. 需求获取技术
7. 需求获取障碍
# 第三讲
1. 什么是用例模型
2. 用例模型的作用是什么
3. 什么是用例
4. 用例建模的步骤和方法
    * 识别参与者
    * 识别用例
    * 用例详述
    * 用例活动图
5. 包含和扩展用例区别
6. 用例模型包含内容
# 第四讲 分析到设计
1. 用例分析的作用和目的
2. 分析类的种类和职责
3. 识别分析类的方法
4. 创建分析模型的步骤
5. 概念模型的作用和意义
6. 创建概念模型的步骤和方法
7. 分析模型包含的内容
# 第五讲
1. 架构分析与用例分析
2. 架构设计的总体步骤
3. 概念架构设计的方法与意义
4. 细化架构多视图法
# 第六讲 详细设计
1. 组件的构成
2. 设计元素
3. 设计子系统和包的区别
4. 设计子系统设计的方法
# 第七讲
1. 用户界面设计的原则
# 第八讲
1. 数据模型的层次
2. 对象模型和关系模型的映射