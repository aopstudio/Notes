# 第一章
## 处理器组成
处理器从逻辑上包含两个主要部件：
* **数据通路**：处理器中执行算术操作的部分，包括ALU、通用寄存器等
* **控制器**：处理器中根据程序程序的指令控制数据通路、存储器

## 主要性能指标
* CPU时钟周期：主频的倒数，CPU中最小的时间单位
* 主频：内部主时钟的频率
* CPI：一条指令所需的时钟周期数

## Amdahl定律
改进后的执行时间=受改进影响的执行时间/改进量+不受影响的执行时间

# 第二章
## 原码、反码、补码
正数：原码、反码、补码相同

负数：
* 原码：符号位为1，尾数大小为绝对值
* 反码：在原码的基础上，除符号位外全部取反
* 补码：反码+1

移码（偏移量为2的n-1次方时）：补码的符号位取反

负数补码转原码：尾数取反后加1（和原码转补码步骤一样）

补码（包括正数和负数）取反的快速方法：对包括符号位在内的每一位取反，然后加1

## MIPS指令的表示
### R型指令
![](https://img-blog.csdnimg.cn/20210515163722774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU3NDQ2Mjg0,size_16,color_FFFFFF,t_70)
* op：指令的基本操作，通常称为**操作码**（R型指令固定为000000），**6位**
* rs、rt：两个源操作数所在的寄存器号
* rd：目的操作数所在的寄存器号
* shamt：位移量，执行移位操作的时候指明需要移动的次数
* func：功能。一般称为**功能码**，用于知名op字段中操作的特定变式，**6位**

add指令的func是32，即100000，sub指令的func是34，即100010
### I型指令
![](https://img-blog.csdnimg.cn/20210515165800755.png)
* immediate：常量，**16位**

### J型指令
![](https://img-blog.csdnimg.cn/20210515172043999.png)
![](https://img-blog.csdnimg.cn/2021051517212342.png)
* address：跳转地址，**26位**

## 计算机硬件对过程的支持
过程：根据提供的参数执行一定任务的存储的子程序，即函数

过程运行的6个步骤
1. 将参数放在过程可以访问的位置
2. 将控制转交给过程
3. 获得过程所属的存储资源
4. 执行需要的任务
5. 将结果的值放在调用程序可以访问的位置
6. 将控制返回初始点，因为一个过程可能由一个程序中的多个点调用

MPIS在为过程分配寄存器时遵循以下约定：
* $a0~\$a3:用于传递参数
* $v0~\$v1:用于返回值
* $ra:用于返回起始点的返回地址寄存器

存储在寄存器$ra中的链接部分称为**返回地址**

跳转和链接指令：**jal指令**，该指令跳转到某个地址的同时将下一条指令的地址保存在寄存器$ra中，保存的值实际上是PC+4

## MIPS分配内存的约定
* 代码段：存放二进制机器代码
* 静态数据段：包含全局变量和常量
* 堆：存放动态分配的空间
* 栈：存放局部变量、函数参数等

栈和堆面对面相互增长，从而在两个段此消彼长的过程中达到内存的高效使用

## MIPS寻址模式
1. **立即数寻址**：
所提供的操作数紧跟在操作码后面，与操作码一起放在指令代码段中，不需要到其他地址单元中去取。这种寻址方式速度**最快**
访存次数：0
2. **寄存器寻址**：
在指令中指出需要使用的寄存器，操作数有效地址在寄存器中
访存次数：0
3. **基址寻址**或**偏移寻址**：
CPU中基址寄存器BR的内容加上指令字中形式地址A决定操作数在内存中的实际地址。BR的内容由操作系统决定，在程序执行过程中BR的内容不可变，而形式地址是可变的。基址寻址方式适合解决动态定位的问题
访存次数：1
4. **PC相对寻址**：
地址是PC和指令中常数的和。由于PC会提前递增，因此实际上是相对于下一条指令的地址（PC+4），而不是相对于当前指令（PC）
5. **伪直接寻址**：
跳转地址由指令中26位字段和PC高位相连而成

# 第三章
## IEEE 754
![](https://www.fleaplc.it/images/Articoli/FloatToDW/Immagini/IEEE753_32Single_Wiki.jpg)
单精度：
一位符号位，8位阶码，23位尾数
阶码是移码，偏置量为127。计算时取出阶码要减127才是阶数
尾数是原码，隐含了小数点左边的1

# 第四章
## 数据通路的概念
定义：处理器中执行算术操作的部分

数据通路部件：一个用来操作或保存处理器中数据的单元。在MIPS中，包括指令存储器、数据存储器、寄存器堆、ALU和加法器

程序计数器（PC）：存放下一条将要被执行指令的地址的寄存器

数据通路功能部件包含两种不同的逻辑单元：
* **组合单元**：处理数据值，它们的输出只取决于当前的输入，如与门或ALU
* **状态单元**：带有内部存储功能，包含*状态*，如寄存器或存储器

## 流水线概述
流水线加速比=非流水线指令执行时间/流水线指令执行时间


在理想情况且有大量指令的情况下，流水线所带来的加速比与流水线的级数近似相同，即
流水线指令执行时间=非流水线指令执行时间/流水线级数

流水线所带来的性能提高是通过**增加指令的吞吐率，而不是减少单条指令的执行时间**实现的

## 流水线冒险
### 结构冒险
如果一条指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务，那就导致了结构冒险

解决方案：
1. 使用流水线阻塞
2. 分别设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于**资源重复配置**
### 数据冒险
因前一条指令无法提供后一条指令执行所需数据而导致指令不能在预定的时钟周期内执行的情况

解决方案：
使用旁路或流水线阻塞

### 控制冒险
如果现在要执行哪条指令，是由之前指令（条件转移类指令）的运行结果决定，而现在那条之前指令的结果还没产生，就导致了控制冒险

解决方案：
使用分支预测（假设某种情况发生，直接执行该种情况）或延迟决定（先干别的事）

# 第五章
## 局部性原理
* 时间局部性：某个数据项在被访问之后可能很快被再次访问
* 空间局部性：某个数据项在被访问之后，与其地址相近的数据项可能很快被访问

利用局部性原理将计算机存储器组织称为**存储器层次结构**

存储器层次结构由不同速度和容量的多级存储器构成

## cache写操作策略
1. **写直达法（写直通、全写）**
每次写操作总是同时更新cache和内存，以保持二者一致性。性能较差
2. **写回法**
发生写操作时，仅仅写入cache块中。只有当修改过的块被替换时才需要写到内存中。实现复杂，存在一致性问题

## Cache地址结构
### 直接映射
![](https://img-blog.csdn.net/20171116105027707)
Cache的存储空间得不到充分利用，但查询效率高，硬件简单

地址结构：

主存字块标记 | Cache字块标记 | 字块内地址
### 全相联映射
![](https://img-blog.csdn.net/20171116105644715)
主存中的所有块可以放到cache中的任意位置

适合于小容量Cache采用

地址结构：

主存子块标记 | 字块内地址
### 组相联映射
![](https://img-blog.csdn.net/20180425165250180)

几路组相联就是一个组里面有几个块

主存中的块映射到指定的组，只能放到cache该组中，但组内位置可以随意放

地址结构：

主存字块标记 | 组地址 | 字块内地址

一路组相联就是直接映射

## 可信度相关名词
* MTTR：故障发生后平均修复时间（Mean Time To Repair）
* MTTF：平均无故障工作时间（Mean Time To Failure）
   * 可用性=MTTF/(MTTF+MTTR)
* MTBF：系统两次故障发生时间之间的时间段的平均值(Mean Time Between Failure)
   * MTBF=MTTR+MTTF

## 可靠性
可靠性是一个系统或模块能够持续提供用户需求的服务的度量，即从开始使用到失效的时间间隔

平均无故障时间（MTTF）是一个可靠性度量方法
与之相关的一个术语是年失效率（AFR），它是指在给定MTTF情况下，在一年内预期的的器件失效比例

## 可用性
可用性=MTTF/(MTTF+MTTR)

## 页式虚拟存储器
![](https://img-blog.csdnimg.cn/20190902214005168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjkxOTM0,size_16,color_FFFFFF,t_70)
页：进程中的块（进程被分成许多大小相同的块）
页框：内存中的块（内存被分成许多大小相同的块）
页的大小=页框大小
页表：存储进程中的每一页所对应的页框的位置（进程中的每一块对应在内存中的位置）

页表项： 页号（标记） | 页框号（虚页号）

页表项地址：指向页表中的元素（即页表项）

逻辑地址（页号，偏移量） （逻辑地址就是虚拟地址）
物理地址（页框号，偏移量）
###  TLB（快表）
![](https://img-blog.csdnimg.cn/20190902214637696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjkxOTM0,size_16,color_FFFFFF,t_70)
**放在主存中的页表叫做慢表**

TLB采用全相联映射，采用SRAM实现

TLB是页表的子集，相当于页表的cache。TLB命中，页表一定命中；页表命中，TLB不一定命中

TLB每行都有有效位，有效位为1才能用

TLB命中，访问某个逻辑地址只需要一次访问内存；TLB没有命中，访问某个逻辑地址需要两次访问内存
###  虚拟地址结构
虚页号 | 页内地址

虚页号又可分为：页目录号 | 页号

### 单级页表的问题
页表必须连续存放，当页表很大时，需要占用很多个连续的页框
解决方案：多级页表

没有必要让整个页表中指向的所有页常驻内存，因为进程在一段时间内可能只需要访问几个特定的页面
解决方案：在需要访问的时候才把页面调入内存，为此在页表项中增加**标志位**表示页表项对应的页是否在内存中
### 两级页表
把页表项分组，变成多个小页表，存在内存不同的位置

对不同的小页表也要建立一张表用来检索，称为**页目录表**

地址结构：
一级页号+两级页号+页内地址

需要多一次访存

#### 多级页表
如果采用多级页表，那么各级页表的大小不能超过一个页面所能存储的最多页表项的数量。
原因：本来多级页表就是为了解决当页表很大时，需要占用很多个连续的页框的问题。如果一个页表超过了一个页框的空间，就失去了采用多级页表的意义

例题：
字节编址，40位逻辑地址，页面大小4KB，页表项大小4B，需要采用（3）级页表

解：页内地址12位
页号位数=40-12=28位
一页最多能存2^10^个页表项。所以每级页表的页表项地址的最大位数为10

28=10+10+8
所以采用3级页表
## 段式虚拟存储器
![](https://img-blog.csdnimg.cn/20190902214202826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjkxOTM0,size_16,color_FFFFFF,t_70)
段的大小不固定

段表寄存器：存储了段表起始地址和段表长度（段表项个数）

段表项地址：指向段表中的元素（即段表项）
### 虚拟地址
段号+段内地址

段号决定了每个进程最多分多少个段
段内地址决定了每个段的最大长度是多少

物理地址按段为单位分配

### 段表
段表项包含：标志位、段号、段起点（段基址）和段长度

每个段表项的长度相同

问题求段地址，答案可能是越界
## 段页式虚拟存储器
把程序按逻辑分段，每段再分页，主存空间页划分为大小相等的页
程序对主存的调入调出仍以页为单位

每个程序对应一个段表，每段对应一个页表

虚拟地址：段号+段内页号+页内地址

需要检查页号是否越界（因为各个段所包含的页数不同）

需要三次访存
### 段表
段表项存放：页表长度+页表存放块号
### 页表
页表项存放：页号+内存块号

## 分页和分段比较
页对用户是不可见的；分段对用户是可见的，用户编程时需要给出段名

页的大小固定，段的大小不固定

分页的地址空间是一维的，只要给出一个记忆符即可表示一个地址；分段地址空间是二维的，既要给出段名，也要给出段内地址；段页式也是二维的

分段比分页更容易实现信息的共享和保护

程序正在运行时，由**操作系统**完成地址映射
## 请求分页
页表包含：
1. 标志位（状态位）：页面是否调入内存
2. 访问字段：记录最近访问几次，或上次访问时间，供置换算法使用
3. 修改位：页面调入内存后是否修改过