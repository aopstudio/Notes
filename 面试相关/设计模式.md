## SOLID设计原则
### [S] Single Responsibility Principle (单一功能原则)

单一功能原则 ：单一功能原则 认为对象应该仅具有一种单一功能的概念。

换句话说就是让一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。

### [O] Open Close Principle （开闭原则）

开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。

软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。
### [L] Liskov Substitution Principle（里氏替换原则）
里氏替换原则 ：程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
2. 子类可以增加自己特有的方法
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样

类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件

里氏替换原则LSP是使代码符合开闭原则的一个重要保证。

### [I] Interface Segregation Principle（接口隔离原则）
接口隔离原则 ：接口隔离原则 认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 对接口进行更细粒度的划分

### [D] Dependency Inversion Principle（依赖反转原则）
高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。

依赖反转原则： 依赖反转原则 认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注入是该原则的一种实现方式。

依赖倒置原则(Dependency Inversion Principle，DIP)规定：代码应当取决于抽象概念，而不是具体实现。

### 合成复用原则
优先使用对象组合，而不是通过继承来达到复用的目的

继承的耦合度太高。假设类A负责项目中的数据库连接操作，同时类E, F, G都继承了类A，那么如果有一天，项目中的数据库连接不再由类A，而是由类C负责，则需要将复用A中方法的所有子类都进行修改，费时费力。

同时父类的一些实现细节会暴露给子类，并不安全

可以改成将A对象作为B类连接方法的参数传入，并在方法体中通过传入的A对象执行方法；或者将A作为B的成员变量给进来

### 迪米特法则
每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位

一个类对其他的类的交互越少越好，当一个类发生改动，与其相关的类需要尽可能少的受影响

还是降低耦合度

# 创建型设计模式
## 简单工厂模式（不属于23种设计模式）
替代了传统直接new来创建对象的方式。如果所有对象都用new创建，当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，岂不是得挨个去修改？因此可以将那些需要频繁的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改

通过传入参数来判断该创建什么类型的对象

```java
public abstract class Fruit{    // 水果抽象类
    private final String name;
    public Fruit(String name){
        this.name=name;
    }
    @Override
    public String toString(){
        return name+"@"+hashCode();
    }
}

public class Apple extends Fruit{
    public Apple(){
        super("苹果");
    }
}
public class Orange extends Fruit{
    public Orange(){
        super("橘子");
    }
}

public class FruitFactory{
    public static Fruit getFruit(String type){
        switch(type){
            case "苹果":
                return new Apple();
            case "橘子":
                return new Orange();
        }
    }
}
public static void main(String[] args){
    Fruit fruit = FruitFactory.getFruit("橘子");
    System.out.println(fruit);
}
```
但存在一些问题。为了符合开闭原则，类、模块、函数应该对扩展开放，对修改关闭。但是如果希望新增一种水果，比如桃子，就需要修改工厂提供的创建水果的方法，违背了开闭原则。

## 工厂方法模式
利用对扩展开放，对修改关闭的性质，将简单工厂模式修改为工厂方法模式

```java
public abstract class FruitFactory<T extends Fruit>{    // 将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型
    public abstract T getFruit();   // 不同的水果工厂，通过此方法生产不同的水果
}

public class AppleFactory extends FruitFactory<Apple>{
    @Override
    publid Apple getFruit(){
        return new Apple();
    }
}
```

如果新增了水果类型，直接创建一个新的水果工厂就行，不需要修改之前已经编写好的内容

## 抽象工厂模式
工厂方法模式只使用于简单对象，当需要生产许多个产品族的时候，这种模式就有点乏力
![alt text](https://file%2B.vscode-resource.vscode-cdn.net/var/folders/8j/9tptyt0x6cg58rglpp99p35w0000gn/T/TemporaryItems/NSIRD_screencaptureui_UA0hAb/%E6%88%AA%E5%B1%8F2024-03-22%2021.05.07.png?version%3D1711112710767)

以上产品都是成族出现的，如果按照工厂方法模式来设计，需要单独设计9个工厂来生产上述产品

可以使用抽象工厂模型，将多个产品都放在同一个工厂中生产，将不同的产品族进行划分，比如小米工厂，可以生产整条产品线上的内容，包括手机、平板、路由

所以只需要一个抽象工厂即可
```java
public abstract class Router{}  // 路由器抽象类
public class HuaweiRouter extends Router{}  // 华为路由器类
public abstract class Table{}
public class HuaweiTable extends Table{}
public abstract class Phone{}
public class HuaweiPhone extends Phone{}
public abstract class AbstractFactory{  // 抽象工厂
    public abstract Router getRouter();
    public abstract Table getTable();
    public abstract Phone getPhone();
}
public class HuaweiFactory extends AbstractFactory{
    public Router getRouter(){
        return new HuaweiRouter()
    }
    public Table getTable(){
        return new HuaweiTable()
    }
    public Phone getPhone(){
        return new HuaweiPhone()
    }
}
```
但缺点还是有，如果产品族新增了产品，就不得不为每个产品族的工厂都去添加新产品的生产方法，违背了开闭原则

## 建造者模式
通过建造者不断配置参数或是内容，当配置完所有内容后，最后再进行对象的构建

相比直接去new一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置，同时如果一个类的构造方法参数过多，得一个个对应去填，非常麻烦，而且可能填错位。我们通过建造者模式来创建这个对象，会更加优雅。

## 单例模式

### 饿汉式（线程安全）
```java
public class Singleton {
    private final static Singleton INSTANCE = new Singleton();   //用于引用全局唯一的单例对象，在一开始就创建好
    
    private Singleton() {}   //不允许随便new，需要对象直接找getInstance
    
    public static Singleton getInstance(){   //获取全局唯一的单例对象
        return INSTANCE;
    }
}
// 用的时候直接取
Singleton singleton = Singleton.getInstance();
```
### 懒汉式（线程不安全）
```java
public class Singleton{
    private static Singleton INSTANCE;
    private Singleton(){}
    public static Singleton getInstance(){
        if(INSTANCE==null){
            INSTANCE=new Singleton();
        }
        return INSTANCE;
    }
}
```
多线程会同时调用getInstance()方法，生成多个INSTANCE

### 懒汉式（线程安全，方法加锁）
```java
public statc synchronized Singleton getInstance(){  // 方法必须添加synchronized关键字加锁
    if(INSTANCE==null){
        INSTANCE=new Singleton();
    }
    return INSTANCE;
}
```

### 懒汉式（线程安全，只对赋值部分加锁，同时双重检查锁定）
```java
public class Singleton{
    private static volatile Singleton INSTANCE;

    private Singleton(){}

    public statc Singleton getInstance(){
        if(INSTANCE==null){
            synchronized(Singleton.class){
                if(INSTANCE==null){
                    INSTANCE=new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```
### 懒汉式（线程安全，静态内部类实现）
```java
public class Singleton{
    private Singleton(){}
    private static class Holder{    // 由静态内部类持有单例对象，但是根据类加载特性，仅使用Singleton类时，不会对静态内部类进行初始化
        private final static Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance(){  // 只有真正使用内部类时，才会进行类初始化
        return Holder.INSTANCE; // 直接获取内部类中的
    }
}
```
最完美的懒汉式解决方案，没有进行任何加锁操作，也能保证线程安全。不过并不是所有语言都支持

## 原型模式
和对象的拷贝息息相关，使用原型示例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。

原型模式，实际上是从原型实例复制克隆出新实例，而绝不是从类去实例化

* 浅拷贝：对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象
* 深拷贝：无论是基本类型还是引用类型，深拷贝会将引用类型的所有内部，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝

Java提供的clone方法只实现浅拷贝，深拷贝需要自己重写Cloneable接口中的clone()方法

# 结构型设计模式
## 类/对象适配器模式（既可用于类，也可用于对象）
例如我们程序员经常遇到的电脑上提供的端口与要插入的接头匹配不上，而我们则可以通过一个中间的适配器（扩展坞）将两边连接起来。

```java
public class TestSupplier {   //现在的手机供应商，并不是test方法所需要的那种类型
    public String doSupply(){
        return "iPhone 14 Pro";
    }
}
public interface Target {    // 实际test方法需要的手机供应商
    String supply();
}
public class Main {
    public static void main(String[] args) {
        TestSupplier supplier = new TestSupplier();
      	test( ? );   //我们没有Target类型的手机供应商，只有其他的TestSupplier，那这里该填个啥
    }

    public static void test(Target target){   //现在我们需要调用test方法，但是test方法需要Target类型的手机供应商
        System.out.println("成功得到："+target.supply());
    }
}
```

### 使用类适配器解决上述不兼容问题
```java
public class TestAdapter extends TestSupplier implements Target{
    // 让适配器继承TestSupplier并且继承Target接口
    @Override
    public String supply(){ // 接着实现supply方法，直接使用TestSupplier提供的实现
        return super.doSupply();
    }
}
```
之后就可以适配器来完成test
```java
public static void main(String[] args) {
    TestAdapter adapter = new TestAdapter();
    test(adapter);
}

public static void test(Target target){
    System.out.println("成功得到："+target.supply());
}
```

但是类适配器需要占用一个继承位，如果此时Target不是接口而是抽象类，由于java不支持多继承，就无法实现

### 使用对象适配器（更常用的方法）
```java
public class TestAdapter implements Target{
    TestSupplier supplier;  // 设置一个TestSupplier类型的成员变量
    public TestAdapter(TestSupplier supplier){
        this.supplier = supplier;
    }
    @Override
    public String supply(){
        return supplier.doSupply(); // 调用成员变量的doSupply方法
    }
}
```
将对象以组合的形式存放在TestAdapter中

## 桥接模式
抽象和实现可以沿着各自的维度来进行变化，不再是固定的绑定关系。比如一杯奶茶，奶茶类型和奶茶尺寸

一杯奶茶除了类型之外，还分大中小杯，甚至可能还分加什么配料，这个时候，如果我们按照接口实现的写法：
```java
public interface Tea {   //由具体类型的奶茶实现
    String getType();   //不同的奶茶返回的类型不同
}
public interface Size {   //分大杯小杯中杯
    String getSize();
}
/**
 * 大杯芋圆啵啵奶茶
 */
public class LargeKissTea implements Tea, Size{
    @Override
    public String getSize() {
        return "大杯";
    }

    @Override
    public String getType() {
        return "芋圆啵啵奶茶";
    }
}
```

现在面临的问题是，维度太多，不可能各种类型各种尺寸的奶茶都去创建一个类，那么我们就还是单独对这些接口进行简单的扩展，单独对不同的维度进行控制，但是如何实现呢？我们不妨将奶茶的类型作为最基本的抽象类，然后对尺寸、配料等属性进行桥接：

```java
public abstract class AbstractTea{
    protected Size size;    // 尺寸作为桥接属性存放在类中
    protected AbstractTea(Size size){   // 在构造时需要知道尺寸属性
        this.size = size;
    }
    public abstract String getType();   // 具体类型依然是由子类决定
}
```
还需要添加其他维度的方法，继续编写一个子类
```java
public abstract class RefinedAbstractTea extends AbstractTea{
    protected RefinedAbstractTea(Size size){
        super(size);
    }
    public String getSize(){    // 添加尺寸维度获取方式
        return size.getSize();
    }
}

public class Large implements Size{

    @Override
    public String getSize() {
        return "大杯";
    }
}
```
如果需要一个大杯的波波芋圆奶茶，只需要：
```java
public class KissTea extends RefinedAbstractTea{   //创建一个啵啵芋圆奶茶的子类
    protected KissTea(Size size) {   //在构造时需要指定具体的大小实现
        super(size);
    }

    @Override
    public String getType() {
        return "啵啵芋圆奶茶";   //返回奶茶类型
    }
}
```
现在将两个维度拆开，可以分别进行配置
```java
public static void main(String[] args) {
    KissTea tea = new KissTea(new Large());
    System.out.println(tea.getType());
    System.out.println(tea.getSize());
}
```
## 组合模式
将多个组件进行组合，让用户可以对它们进行一致性处理

比如文件夹中有很多子文件夹和文件，组合模式可以对整个树形结构上的所有节点进行递归处理。比如现在希望将所有文件夹中的文件的名称前面都添加一个前缀，那么就可以使用组合模式

```java
/**
 * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法
 */
public abstract class Component {
    public abstract void addComponent(Component component);    //添加子组件
    public abstract void removeComponent(Component component);   //删除子组件
    public abstract Component getChild(int index);   //获取子组件
    public abstract void test();   //执行对应的业务方法，比如修改文件名称
}

public class Directory extends Component{   //目录可以包含多个文件或目录

    List<Component> child = new ArrayList<>();   //这里我们使用List来存放目录中的子组件

    @Override
    public void addComponent(Component component) {
        child.add(component);
    }

    @Override
    public void removeComponent(Component component) {
        child.remove(component);
    }

    @Override
    public Component getChild(int index) {
        return child.get(index);
    }

    @Override
    public void test() {
        child.forEach(Component::test);   //将继续调用所有子组件的test方法执行业务
    }
}

public class File extends Component{   //文件就相当于是树叶，无法再继续添加子组件了

    @Override
    public void addComponent(Component component) {
        throw new UnsupportedOperationException();   //不支持这些操作了
    }

    @Override
    public void removeComponent(Component component) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Component getChild(int index) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void test() {
        System.out.println("文件名称修改成功！"+this);   //具体的名称修改操作
    }
}

```
来测试一下：
```java
public static void main(String[] args) {
    Directory outer = new Directory();   //新建一个外层目录
    Directory inner = new Directory();   //新建一个内层目录
    outer.addComponent(inner);
    outer.addComponent(new File());   //在内层目录和外层目录都添加点文件，注意别导错包了
    inner.addComponent(new File());
    inner.addComponent(new File());
    outer.test();    //开始执行文件名称修改操作
}
```
## 装饰模式
在不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系