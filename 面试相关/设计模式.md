## SOLID设计原则
### [S] Single Responsibility Principle (单一功能原则)

单一功能原则 ：单一功能原则 认为对象应该仅具有一种单一功能的概念。

换句话说就是让一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。

### [O] Open Close Principle （开闭原则）

开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。

软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。
### [L] Liskov Substitution Principle（里氏替换原则）
里氏替换原则 ：程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
2. 子类可以增加自己特有的方法
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样

类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件

里氏替换原则LSP是使代码符合开闭原则的一个重要保证。

### [I] Interface Segregation Principle（接口隔离原则）
接口隔离原则 ：接口隔离原则 认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 对接口进行更细粒度的划分

### [D] Dependency Inversion Principle（依赖反转原则）
高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。

依赖反转原则： 依赖反转原则 认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注入是该原则的一种实现方式。

依赖倒置原则(Dependency Inversion Principle，DIP)规定：代码应当取决于抽象概念，而不是具体实现。

### 合成复用原则
优先使用对象组合，而不是通过继承来达到复用的目的

继承的耦合度太高。假设类A负责项目中的数据库连接操作，同时类E, F, G都继承了类A，那么如果有一天，项目中的数据库连接不再由类A，而是由类C负责，则需要将复用A中方法的所有子类都进行修改，费时费力。

同时父类的一些实现细节会暴露给子类，并不安全

可以改成将A对象作为B类连接方法的参数传入，并在方法体中通过传入的A对象执行方法；或者将A作为B的成员变量给进来

### 迪米特法则
每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位

一个类对其他的类的交互越少越好，当一个类发生改动，与其相关的类需要尽可能少的受影响

还是降低耦合度

# 设计模式
## 简单工厂模式（不属于23种设计模式）
替代了传统直接new来创建对象的方式。如果所有对象都用new创建，当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，岂不是得挨个去修改？因此可以将那些需要频繁的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改

通过传入参数来判断该创建什么类型的对象

```java
public abstract class Fruit{    // 水果抽象类
    private final String name;
    public Fruit(String name){
        this.name=name;
    }
    @Override
    public String toString(){
        return name+"@"+hashCode();
    }
}

public class Apple extends Fruit{
    public Apple(){
        super("苹果");
    }
}
public class Orange extends Fruit{
    public Orange(){
        super("橘子");
    }
}

public class FruitFactory{
    public static Fruit getFruit(String type){
        switch(type){
            case "苹果":
                return new Apple();
            case "橘子":
                return new Orange();
        }
    }
}
public static void main(String[] args){
    Fruit fruit = FruitFactory.getFruit("橘子");
    System.out.println(fruit);
}
```
但存在一些问题。为了符合开闭原则，类、模块、函数应该对扩展开放，对修改关闭。但是如果希望新增一种水果，比如桃子，就需要修改工厂提供的创建水果的方法，违背了开闭原则。

## 工厂方法模式
利用对扩展开放，对修改关闭的性质，将简单工厂模式修改为工厂方法模式

```java
public abstract class FruitFactory<T extends Fruit>{    // 将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型
    public abstract T getFruit();   // 不同的水果工厂，通过此方法生产不同的水果
}

public class AppleFactory extends FruitFactory<Apple>{
    @Override
    publid Apple getFruit(){
        return new Apple();
    }
}
```

如果新增了水果类型，直接创建一个新的水果工厂就行，不需要修改之前已经编写好的内容

## 抽象工厂模式
工厂方法模式只使用于简单对象，当需要生产许多个产品族的时候，这种模式就有点乏力
![alt text](https://file%2B.vscode-resource.vscode-cdn.net/var/folders/8j/9tptyt0x6cg58rglpp99p35w0000gn/T/TemporaryItems/NSIRD_screencaptureui_UA0hAb/%E6%88%AA%E5%B1%8F2024-03-22%2021.05.07.png?version%3D1711112710767)

以上产品都是成族出现的，如果按照工厂方法模式来设计，需要单独设计9个工厂来生产上述产品

可以使用抽象工厂模型，将多个产品都放在同一个工厂中生产，将不同的产品族进行划分，比如小米工厂，可以生产整条产品线上的内容，包括手机、平板、路由

所以只需要一个抽象工厂即可
```java
public abstract class Router{}  // 路由器抽象类
public class HuaweiRouter extends Router{}  // 华为路由器类
public abstract class Table{}
public class HuaweiTable extends Table{}
public abstract class Phone{}
public class HuaweiPhone extends Phone{}
public abstract class AbstractFactory{  // 抽象工厂
    public abstract Router getRouter();
    public abstract Table getTable();
    public abstract Phone getPhone();
}
public class HuaweiFactory extends AbstractFactory{
    public Router getRouter(){
        return new HuaweiRouter()
    }
    public Table getTable(){
        return new HuaweiTable()
    }
    public Phone getPhone(){
        return new HuaweiPhone()
    }
}
```
但缺点还是有，如果产品族新增了产品，就不得不为每个产品族的工厂都去添加新产品的生产方法，违背了开闭原则

## 建造者模式
通过建造者不断配置参数或是内容，当配置完所有内容后，最后再进行对象的构建