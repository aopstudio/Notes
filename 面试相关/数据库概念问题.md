## 数据库的特点
数据共享、数据独立、减少数据冗余、避免数据不一致和加强数据保护

## 锁
![锁机制](images/锁机制.png)
### 行锁
行锁，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。

### 表锁
表锁，和行锁相对应，给这个表加上锁。


### 共享锁（S锁）
共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。


### 排他锁（X锁）
用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。

如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

### 乐观锁
乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

### 悲观锁
与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

### 什么时候使用乐观锁？
资源提交冲突，其他使用方需要重新读取资源，会增加读的次数，但是可以面对高并发场景，前提是如果出现提交失败，用户是可以接受的。因此一般乐观锁只用在高并发、多读少写的场景。
其中：GIT,SVN,CVS等代码版本控制管理器，就是一个乐观锁使用很好的场景，例如：A、B程序员，同时从SVN服务器上下载了code.html文件，当A完成提交后，此时B再提交，那么会报版本冲突，此时需要B进行版本处理合并后，再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁，那么意味者所有程序员都必须一个一个等待操作提交完，才能访问文件，这是难以接受的。

### 什么时候使用悲观锁？
一旦通过悲观锁锁定一个资源，那么其他需要操作该资源的使用方，只能等待直到锁被释放，好处在于可以减少并发，但是当并发量非常大的时候，由于锁消耗资源，并且可能锁定时间过长，容易导致系统性能下降，资源消耗严重。因此一般我们可以在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，会选择悲观锁进行。


## 数据库一对多
1.一对多关系处理：

通过学生和班级问题了解一对多：

设计数据库表：只需在 学生表 中多添加一个班级号的ID；

注：在数据库中表中初学时，还是通过添加主外键约束，避免删除数据时造成数据混乱！
## 数据库多对多
2.多对多关系处理：

通过学生选课了解多对多问题的处理：

在多对多中在一个表中添加一个字段就行不通了，所以处理多对多表问题时，就要考虑建立关系表了

## LIKE子句通配符
通配符	|描述
-------|---
%	   |替代任意子串（包括空字符）
_	   |仅替代一个字符
[charlist]	|字符列中的任何单一字符
[^charlist]或者[!charlist]| 不在字符列中的任何单一字符

## 视图
视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。

1. 视图能简化用户操作
2. 视图使用户能以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
4. 视图能够对机密数据提供安全保护
5. 适当的利用视图可以更清晰地表达查询

```sql
CREATE VIEW 视图名(列1，列2...)
AS SELECT (列1，列2...)
FROM ...;
```
### 视图包含下列结构是不可以更新（update）的
1. 集合运算符 union，union all, intersect，minus
2. distinct关键字
3. group by,order by,connect by,或者start with
4. 子查询
5. 分组函数
6. 需要更新的列不是视图定义的
7. 具有连接查询(可以更新键值保存表的数据)
8. 违反基表的约束条件；连接视图是指基于多表连接查询创建的视图（一般不容易修改，但通用instead of触发器可以实现修改的功能）

## 触发器
触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

```sql
Create trigger trigger_name trigger_time trigger_event on tb_name for each row trigger_stmt;
```
trigger_time ：触发器的触发事件，可以为before（在检查约束前触发）
或after（在检查约束后触发）；

trigger_event：是触发器的触发事件，包括insert、update和delete；

tb_name： 表示建立触发器的表名，就是在哪张表上建立触发器

trigger_stmt： 触发器的程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句；

FOR EACH ROW：表示任何一条记录上的操作满足触发事件都会触发该触发器。

例子：
```sql
create trigger trigger01 after update on g for each ROW-- 创建触发器
```

### 三大范式
第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。

第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）

第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。

第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

## 存储过程
存储过程是一些预编译的SQL语句，执行效率比较高
一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
可以一定程度上确保数据安全

## 事务
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
### Atomic(原子性)
一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。（oracle通过redo和undo日志保证）

### Consistency(一致性)
应用系统从一个正确的状态到另一个正确的状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，比如打破了原有的一些约束，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

### Isolation(隔离性)
指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

一个事物所做的修改在最终提交前，对其他事物是不可见的

### Durability(持久性)
指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

## 读取限制
### 脏读（读取未提交数据）
事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。

### 不可重复读（前后多次读取，数据内容不一致）
在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。

### 幻读（前后多次读取，数据总量不一致）
在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。

在标准的事务隔离级别中，幻读是由更高的隔离级别 SERIALIZABLE 解决的，但是它也可以通过 MySQL 提供的 Next-Key 锁解决：


## drop、delete与truncate分别在什么场景之下使用？
不再需要一张表的时候，用drop
想删除部分数据行时候，用delete，并且带上where子句
保留表而删除所有数据的时候用truncate

执行速度：drop>truncate>delete

## 什么是视图？以及视图的使用场景有哪些？

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

只暴露部分字段给访问者，所以就建一个虚表，就是视图。
查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 数据库三级模式
数据库系统由外模式、模式和内模式构成。外模式是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图；模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。内模式也称存储模式，是数据物理结构和存储方式的描述。

## 数据库关系运算
数据库常用的关系运算为三种：
1、选择。
2、投影。
3、连接。 
（1）选择，是从二维表中选出符合条件的记录，它是从行的角度对关系进行的运算。
（2）投影，是从二维表中选出所需要的列，它是从列的角度对关系进行的运算。
（3）连接，是同时涉及到两个二维表的运算，它是将两个关系在给定的属性上满足给定条件的记录连接起来而得到的一个新的关系。

## 数据库应用设计

### 需求分析设计
形成需求说明书

### 概念设计阶段
形成概念数据模型（作为进一步设计数据库的依据）

### 逻辑设计阶段
形成逻辑数据模型（从 ER 图向关系模式转换、关系视图设计、模式规范化）

### 物理设计阶段
形成数据库内部模型（此时涉及具体软件硬件环境）。

## 隔离级别
### 读未提交（Read Uncommitted）
使用查询语句不会加锁，可能会读到未提交的行（脏读 Dirty Read）；

可以读到未提交的内容
### 读已提交（Read Committed）
只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（不可重复读 Non-Repeatable Read）；

只能读到已经提交了的内容，但不要求可重复读。比如，在事务两次读取一个数据项期间，另一个事务更新了该数据并提交。
### 可重复读（Repeated Read）
RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)。

在一个事务两次读取一个数据项期间，其他事务不得更新该数据
### 可串行化（Serializable）
从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。

Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。

在这个事务持续期间，禁止其他事务对该表执行插入,更新和删除操作.所有并发问题都可以避免，但性能十分低下

### 默认隔离级别
MySQL 中默认的事务隔离级别就是 REPEATABLE READ，但是它通过 Next-Key 锁也能够在某种程度上解决幻读的问题。

## 存储过程
存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。


## 索引
### 索引是什么
索引是对数据库表中一列或多列的值进行排序的一种数据结构。
### 索引的优点： 
1、通过创建唯一性的索引，可以保证表中数据的唯一性; 
2、加速数据的检索速度; 
3、加快表与表之间的连接; 
4、在使用分组与排序数据检索时，可以显著检索分组与排序的时间; 
5、在查询的过程中使用优化隐藏器，提供系统性能。

### 缺点： 
1、创建索引需要时间，且随着数据量的增加而增加; 
2、索引需要占用物理空间;
3、当对表中数据进行修改时，索引也要动态维护，降低了数据的维护速度。

### 索引的种类有哪些
普通索引：加速查询
唯一索引：加速查询 + 列值唯一 + 可以为null
主键索引：加速查询 + 列值唯一 + 不可为null + 表中只有一个
组合索引：多列值组成一个索引，专用于组合搜索，效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索

### 聚集索引
InnoDB 存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放；聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。

### 辅助索引
数据库将 所有的非聚集索引都划分为辅助索引，但是这个概念对我们理解辅助索引并没有什么帮助；辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。

辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。

使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。
### 什么数据应该添加索引？
Where子句中经常使用的字段应该创建索引

分组字段或者排序字段应该创建索引

两个表的连接字段应该创建索引

存储空间固定的字段更适合选作索引的关键字

占用存储空间少的字段更适合选作索引的关键字 与字符串相比，整数字段更适合

### 哪些数据不适合作为索引？
like '%name%'和like '%name'会使索引失效，只有like 'name%'才会走索引

更新频繁的字段不适合创建索引

不会出现在where子句中的字段
### 索引的缺点
1、创建索引需要时间，且随着数据量的增加而增加; 

2、索引需要占用物理空间;

3、当对表中数据进行修改时，索引也要动态维护，降低了数据的维护速度。

### mysql索引的数据结构是什么？
一般使用B+树做索引
### 你还知道其他的索引类型吗？
Hash索引 B树索引

### B+树和B树对比
不同于B树只适合随机检索，B+树同时支持随机检索和顺序检索；

B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。

B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。

B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

## Hash索引和B树索引区别
### B树索引 
BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如： 

### Hash索引
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 
1. Hash 索引仅仅能满足"=","IN"和"<=>(和=相同）"查询，不能使用范围查询。 
由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

2. Hash 索引无法被用来避免数据的排序操作。 
由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

3. Hash 索引不能利用部分索引键查询。 
对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

4. Hash 索引在任何时候都不能避免表扫描。 
前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

## 多表联合查询
### 笛卡尔积
,连接
把一个表中的每个元素都和另一表中的每个元素进行组合
最后用where子句限定具体条件

### 自然连接
自然连接只考虑在两个关系模式中都出现的属性上取值相同的元组对
```sql
select name,course_id
from instructor natural join teaches
```
类等价于
```sql
select name,course_id
from instructor,teaches
where instructor.ID=teaches.ID
```

但笛卡尔积会把共有属性列显示两次，自然连接只显示一次
### 外连接
保留未匹配上的元组。比如student代表学生信息，takes代表学生选课信息。如果直接用natural join，则会丢失没有选课的学生。如果用外连接，则可以保留未选课的学生信息。
* 左外连接(left outer join)：只保留出现在左外连接运算之前（左边）的关系中的元组
* 右外连接(right outer join)：只保留出现在右外连接运算之后（右边）的关系中的元组
* 全外连接(full outer join)：保留出现在两个关系中的元组

#### 左外连接例子
相比而言，为了与外连接运算相区分，不保留未匹配上元组的连接运算称为内连接

```sql
select *
from student natural left outer join takes;
```

这样查询出的结果中，对于未选课的学生对应的只出现在takes关系模式中的属性上取空值

右外连接和左外连接是对称的，上面的查询可以写成
```sql
select *
from takes natural right outer join student;
```
不过属性的出现顺序不同

#### 全外连接
既可以显示未选课的学生，也可以显示没有人选的课
```sql
select * from
students natural full join takes;
```
---

on子句可以和外连接一起使用，下述查询和`student natural left outer join takes`的查询是相同，不过属性ID在结果中出现两次
```sql
select *
from student left outer join takes on student.ID=takes.ID;
```

### 连接类型和条件
为了把常规连接和外连接区分开来，SQL中把常规连接称作内连接。这样的连接子句使用inner join，不过inner是可选的，直接写join默认就是内连接

## 其他细节
不能使用比较操作符测试 NULL 值，例如=、<或<>。我们必须使用 IS NULL 和 IS NOT NULL 操作符。

不该删除的被删除是删除异常，该删除的未被删除是删除失败

主键与索引：
1. 主键唯一标识一条记录，不能重复的，不允许为空；索引 该字段没有重复值但可以有一个空值
2. 主键用于保证数据完整性；索引用于提高查询排序的速度
3. 主键只能有一个；一个表可以有多个索引

主键约束可以创建表级约束和列级约束，但是主键不能定义在表级或者列级

JDBC四种驱动方式：jdba-odbc桥接、本地API驱动、网络协议驱动和本地协议驱动

数据库中可能存在不一致的数据，主要有以下三个方面：
A.数据冗余；
B.并发控制不当；
C.故障或者错误

一个表只能有一个聚集索引和多个非聚集索引

## 防止SQL注入
### 不要使用动态SQL

避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。

### 不要将敏感数据保留在纯文本中

加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。

### 限制数据库权限和特权

将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。

### 避免直接向用户显示数据库错误

攻击者可以使用这些错误消息来获取有关数据库的信息。

### 对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）

这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。

### 定期测试与数据库交互的Web应用程序

这样做可以帮助捕获可能允许SQL注入的新错误或回归。

### 将数据库更新为最新的可用修补程序

这可以防止攻击者利用旧版本中存在的已知弱点/错误。

## ER图
方形：实体
菱形：关系
椭圆：属性

## mysql性能优化
### 为什么要优化
系统的吞吐量瓶颈往往出现在数据库的访问速度上

随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
数据是存放在磁盘上的，读写速度无法和内存相比
### 如何优化
设计数据库时：数据库表、字段的设计，存储引擎
使用索引，索引优化是对查询性能优化的最有效手段
横向扩展：MySQL集群、负载均衡、读写分离
SQL语句的优化（收效甚微）


## 分库分表
### 垂直拆分
垂直分表 也就是 大表拆小表，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到 扩展表。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的 off-page 问题。

垂直分库 针对的是一个系统中的不同业务进行拆分。将多个业务系统的数据放在单个数据库中（服务化拆分），这会让数据库的单库处理能力成为瓶颈。将单个数据库，按业务进行拆分，同一业务领域的数据表放到同一数据库中。并且多个数据库分布在多个机器上，防止由于单机的磁盘、内存、IO等资源造成 MySQL 性能下降。

数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数等单机硬件资源的瓶颈。

### 水平拆分
目前绝大多数应用采取的两种分库分表规则

* 离散映射：如 mod 或 dayofweek ， 这种类型的映射能够很好的解决热点问题，但带来了数据迁移和历史数据问题。
* 连续映射；如按 id 或 gmt_create_time 的连续范围做映射。这种类型的映射可以避免数据迁移，但又带来热点问题。

随着数据量的增大，每个表或库的数据量都是各自增长。当一个表或库的数据量增长到了一个极限，要加库或加表的时候，介于这种分库分表算法的离散性，必需要做 数据迁移 才能完成。

考虑到数据增长的特点，如果我们以代表时间增长的字段，按递增的范围分库，则可以避免数据迁移。这样的方式下，在数据量再增加达到前几个库/表的上限时，则继续水平增加库表，原先的数据就不需要迁移了。但是这样的方式会带来一个 热点问题：当前的数据量达到某个库表的范围时，所有的插入操作，都集中在这个库/表了。

## InnoDB
InnoDB 使用页作为磁盘管理的最小单位。
数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。

页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面

B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、next_record 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。这样就存在一个命中率的问题，如果一个page中能够相对的存放足够多的行，那么命中率就会相对高一些，性能就会有提升。

B+树底层的叶子节点为一双向链表，因此 **每个页中至少应该有两行记录**，这就决定了 InnoDB 在存储一行数据的时候不能够超过 8kb，但事实上应该更小，因为还有一些 InnoDB 内部数据结构要存储

### InnoDB索引
InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引，但是 B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，然后正如上一节所提到的，数据库把整个页读入到内存中，并在内存中查找具体的数据行。

B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度

B+ 树的叶子节点存放所有指向关键字的指针，节点内部关键字记录和节点之间都根据关键字的大小排列。当顺序递增插入的时候，只有最后一个节点会在满掉的时候引起索引分裂，此时无需移动记录，只需创建一个新的节点即可。而当非递增插入的时候，会使得旧的节点分裂，还可能伴随移动记录，以便使得新数据能够插入其中。一般建议使用一列顺序递增的 ID 来作为主键，但不必是数据库的 autoincrement 字段，只要满足顺序增加即可，如 twitter 的 snowflake 即为顺序递增的 ID 生成器。

### 聚集索引
InnoDB 存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放；聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。

如果没有定义主键，则会使用非空的 UNIQUE键 做主键 ; 如果没有非空的 UNIQUE键 ，则系统生成一个6字节的 rowid 做主键;

聚集索引与表的物理存储方式有着非常密切的关系，所有正常的表应该 有且仅有一个 聚集索引（绝大多数情况下都是主键），表中的所有行记录数据都是按照 聚集索引 的顺序存放的。

当我们使用聚集索引对表中的数据进行检索时，可以直接获得聚集索引所对应的整条行记录数据所在的页，不需要进行第二次操作。

### 辅助索引
数据库将 所有的非聚集索引都划分为辅助索引，但是这个概念对我们理解辅助索引并没有什么帮助；辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。

辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。

辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。

一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。

使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。**辅助索引看where子句中的字段来使用**

### 覆盖索引
聚簇索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录，这种行为被称之为 回表。回表会导致查询时多次读取磁盘，为减少IO MySQL 在辅助索引上进行优化，将辅助索引作为 覆盖索引（Covering index）。在查询的时候，如果 **SELECT 子句中的字段为辅助索引的键（主键就更不用说了）** 则不进行回表，**覆盖索引主要看SELECT子句**

## SQL语句执行顺序
(7) - SELECT
(8) - DISTINCT <select_list>
(1) - FROM <left_table>
(3) - <join_type> JOIN <right_table>
(2) - ON <join_condition>
(4) - WHERE <where_condition>
(5) - GROUP BY <group_by_list>
(6) - HAVING <having_condition>
(9) - ORDER BY <order_by_condition>
(10) - LIMIT <limit_number>

关于 SQL 语句的执行顺序，有三个值得我们注意的地方：

* **FROM 才是 SQL 语句执行的第一步，并非 SELECT**。 数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。
* **SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的**。理解这一点是非常重要的，这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。
* **无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前**。很多人认为每个 UNION 段都能使用 ORDER BY 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。

虽然SQL的逻辑查询是根据上述进行查询，但是数据库也许并不会完全按照逻辑查询处理的方式来进行查询。 MySQL 数据库有两个组件 Parser（分析SQL语句）和 Optimizer（优化）。

从官方手册上看，可以理解为， MySQL 采用了基于开销的优化器，以确定处理查询的最解方式，也就是说执行查询之前，都会先选择一条自以为最优的方案，然后执行这个方案来获取结果。在很多情况下， MySQL 能够计算最佳的可能查询计划，但在某些情况下， MySQL 没有关于数据的足够信息，或者是提供太多的相关数据信息，估测就不那么友好了。

# Redis
## redis持久化的方式
### RDB持久化
原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化
在指定的时间间隔能对你的数据进行快照存储。
RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
### AOF（append only file）持久化
记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据


## 二者优缺点
### RDB
#### 优点
RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。

RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。

相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。

#### 缺点
如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。

RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

### AOF
#### 优点
AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。

AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。

AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。

AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。

#### 缺点
对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。

AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）

以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。

## Redis 为什么是单线程的？
我们要去理解为什么多线程好，多线程好在 IO 慢的时候才能凸显出高性能，因为在一个线程等待 IO 的时候马上切换线程运行。
而在 Redis 中数据都在内存当中，IO 非常快，如果还是采用多线程的话，反而会浪费时间在线程的上下文切换。
