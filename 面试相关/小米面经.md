# python中的可变位置参数和可变关键字参数之间的区别
可变位置参数通常命名为*args，它会自动将对应位置所填的所有位置参数封包为一个元组，在函数中如果打印args这个变量，打印出来的就是一个元组

可变位置参数通常命名为**kwargs，它会自动将对应位置所填的所有关键词参数封包为一个字典，在函数中如果打印kwargs这个变量，打印出来的就是一个字典

# python中的生成器和迭代器有什么不同
迭代器是实现了__iter__方法和__next__方法的类，可以使用for 的方式迭代出容器内的所有数据

1.生成器本身是一种特殊的迭代器，也就是说生成器就是迭代器。

2.生成器会自动实现迭代器协议，也就是说只要我们yield后，自动就生成了next对象包括StopIteration等结构。

3.生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息。对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。

生成器可以通过生成器表达式或者生成器函数来创建。
当我们想得到一个集合时，如果使用普通方法，只能一次性创建出这个集合，然后 return 返回.但如果此时这个集合中的数据非常多，我们就需要在内存中一次性申请非常大的内存空间来存储。
如果我们使用 yield 生成器的方式迭代这个集合，就能解决内存占用大的问题。使用生成器创建这个集合，只有在迭代执行到 yield 时，才会返回一个元素，在这个过程中，不会一次性申请非常大的内存空间。当我们面对这种场景时，使用生成器就非常合适了。

### 生成器表达式
```py
[i**2 for i in old_list] # 列表推导式
(i**2 for i in old_list)  # 生成器表达式  
```

生成器表达式只需要把方括号换成原括号即可
```py
sum([i**2 for i in old_list])
sum(i**2 for i in old_list)
```

使用生成器的优势究竟在哪呢
```py
sum([i for i in 100000000000])
sum(i for i in 100000000000)
```

我们可以查看一下机器的内存，第一个列表推导式的方式大概率会内存爆掉。其实也不难理解，第二种是生成器模式。生成器是使用才迭代，只迭代一次不会存在内存中。所以内存不会一直的增高。

## 二者区别
二者区别
1.迭代器是访问容器的一种方式，也就是说容器已经出现。我们是从已有元素拓印出一份副本，只为我们此次迭代使用。而生成器则是，而生成器则是自己生成元素的。也就是前者是从有到有的复制，而后者则是从无到有的生成。

2.在用法上生成器只需要简单函数写法，配合yield就能实现。而迭代器真正开发中很难使用到。我们可以把生成器看做，python给我们提供的特殊接口实现的迭代器。

# Redis数据类型
字符串、列表、哈希、集合、有序集合

# 常用数据库索引类型
主键索引、唯一索引、普通索引、联合索引

联合索引可以建立多列(列数大于2)的索引,建议列数最多不要越过3列，超过3列，应重新设计表。

# 数据库索引失效的情况
1. 查询条件中有or，即使有部分条件带索引也会失效
2. like查询是以%开头
3. 如果列类型是字符串，那在查询条件中需要将数据用引号引用起来，否则不走索引
4. 索引列上参与计算会导致索引失效
5. 违背最左匹配原则 
explain select * from student where age =18
的索引是和建立在(name,age)组合索引的基础上，当查询条件中没有第一个组合索引的字段(name)会导致索引失效
正例：explain select * from student where age =18 and name ="张三"
    5.1 范围查询使联合索引停止匹配
    如对(a,b,c,d)建立索引,where后条件为`a = 1 and b = 2 and c > 3 and d = 4`。那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了范围查询！
    范围查询使联合索引停止匹配的根本原因是，索引树上非首字段的有序状态依赖前一个字段相等情况，而范围查询破坏了下一个索引字段局部有序状态，导致索引停止匹配
6. 如果mysql估计全表扫描要比使用索引要快，会不适用索引

# 如何建立索引?
重点要的是将区分度高的字段放在前面，区分度低的字段放后面。像性别、状态这种字段区分度就很低，我们一般放后面。

例如假设区分度由大到小为b,a,c。那么我们就对(b,a,c)建立索引。在执行sql的时候，优化器会 帮我们调整where后a,b,c的顺序，让我们用上索引。

# SQL执行顺序
(1) FROM <left_table> 
(2) <join_type> JOIN <right_table> 
(3) ON <join_condition> 
(4) WHERE <where_condition> 
(5) GROUP BY <group_by_list>
(6) WITH {CUBE | ROLLUP} 
(7) HAVING <having_condition> 
(8) SELECT (9) DISTINCT 
(9) ORDER BY <order_by_list> 
(10) <TOP_specification> <select_list>