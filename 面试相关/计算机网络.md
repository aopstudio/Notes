# OSI模型和TCP/IP模型
## OSI七层模型（Open System Interconnect）
即开放系统互连参考模型，是由ISO（International Organization for Standardization）国际标准化组织提出的，用于计算机或通信系统间互联的标准体系。

从上到下可分为七层：每一层都完成特定的功能，并为上一层提供服务，并使用下层所提供的服务。

7、应用层（Application）：为用户的应用程序提供网络服务
6、表示层（Presentation）：将信息表示为一定形式和格式的数据流
5、会话层（Session）：负责通信主机之间会话的建立、管理和拆除，协调通信双方的会话
4、传输层（Transport）：负责通信主机间端到端的连接
3、网络层（Network）：负责将分组从源机送到目的机，包括寻址和最优路径选择等
2、数据链路层（Data Link）：提供可靠的帧传递，实现差错控制、流控等等
1、物理层（Physical）：提供透明的比特流（01流）传递

## TCP/IP四层参考模型
从上到下可分为四层：
4、应用层（Application）：为用户提供所需要的各种服务
3、传输层（Transport）：为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性
2、网际层（Internet）：主要解决主机到主机的通信问题
1、网络接口层（Network Access）：负责监视数据在主机和网络之间的交换

# 传输层
## TCP和UDP协议

## TCP三次握手和四次挥手
### 三次握手（建立连接）：  
* 第一次握手：客户端主机向服务器发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是在报文段的首部中的SYN标志位置为1，代表请求建立连接，称为SYN报文段。客户端随机选择一个初始序号，并将此编号放在SYN报文段的序号字段。该报文段被封装在一个网络层数据报中，发送给服务器。
* 第二次握手：服务器接收到包含SYN报文段的IP数据报，提取出SYN报文段，并向客户TCP发送允许连接的报文段。该报文段也不包含应用层数据，SYN标志位置和ACK标志位置均为1，确认号字段为SYN报文段的编号+1，服务器选择主机的初始序号，并将其放置到TCP报文段首部的序号字段。这个报文段被称为SYNACK报文段。
* 第三次握手：客户端收到SYNACK报文段后，也要给该连接分配缓存和变量。同时再向服务器发送另外一个报文段，ACK标志位置为1，确认号为第二次握手服务端发送的序号+1，对SYNACK报文段给以确认，这个报文段包含了应用层数据。

三次握手的原因：  
* 双方能确知对方的存在
* 允许双方协商一些参数
* 对运输实体资源进行分配

拓展知识：  
因为第二次握手（还没有正式开始传送数据）时，服务器就已经给TCP连接分配了缓存资源，这为经典的DoS攻击即SYN洪泛攻击（SYN flood attack）提供了环境。在这种攻击中，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段纷至沓来，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽。这种SYN洪泛攻击是被记载的众多DoS攻击中的第一种。

解决方法：使用SYN Cookie，第二次连接时不分配资源，而是生成一个Cookie并返回客户端，客户端在第三次握手时能提供这个Cookie才真正分配资源建立连接

![三次握手过程](https://s2.ax1x.com/2019/05/27/VVs7cT.png)
#### 为什么必须三次握手而不是两次
##### 1. 避免历史连接浪费资源
三次握手是为了防止当已失效的连接请求报文段突然又传到服务端，造成双方的不一致，导致资源的浪费。

“已失效的连接请求报文段”指的是这样的情况，客户端发出一个SYN报文段，由于阻塞或者其他原因在网络中滞留，以至于客户端认为丢包了（其实并没有丢），于是重新发出一个SYN报文段，假设这一次顺利完成了，那么双方建立连接。这看起来似乎没什么问题，但网络中有一个隐患，就是那个还在网络中传输的SYN报文段，如果这个SYN在连接期间被服务端收到了，那服务端只会无视它，这样就万事大吉了，但如果是在连接释放之后被收到呢？此时服务端认为有人向他发出连接请求，于是响应一个SYNACK回去，如果采用两次握手的话，那么服务器认为此时连接已经建立好了。但是当客户端收到这个SYNACK时，如果他并没有发起连接，那么他不会理睬这个SYNACK，就当没事发生过（如果客户端此时正好发起连接，那其实他也不会理睬这个SYNACK，因为确认号不对啊。）。那问题就大了，这时候服务器以为连接好了，向客户端发送数据，而客户端处于CLOSED状态，会丢弃这些包，这样就很浪费了。并且还有一个尴尬的问题，就是这个时候当客户端打算发起连接时，服务端又不理睬了，在这里尬这，他们就别想互发数据了。当然这些问题似乎不是不可解决的，当客户端发现服务端老是向自己发数据，而自己总是丢弃，可能会向服务端发一个RST（报文段的RST标记号为1），强制服务端关闭连接。但资源总归是浪费了一会了。而用三次握手就不会出现这样的问题。

###### RST报文
用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。

1. 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；
2. 如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；
##### 2. 同步双方初始序列号TCP 
协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发送出去的数据包中， 哪些是已经被对方收到的；可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
##### 3. 防止洪泛攻击
实际上服务器第二次握手不会分配资源，而是给客户端设置一个cookie，之后第三次握手客户端需要带着这个cookie才能建立连接。如果是两次握手，那么第二次就回分配资源建立连接，则客户端只要一直发送不传输实际数据的SYN请求，服务器资源就会消耗殆尽


### 四次挥手（连接释放）
**客户端和服务器都可以发起**

客户端向服务器发送一个特殊的TCP报文段，该报文段FIN标志位置为1。服务器收到后，给发送方回送一个确认报文段，ACK标志位为0。之后服务器可以继续发送一些尚未发送完毕的数据，发送完毕后，服务器发送它自己的终止报文段，其FIN比特被置为1.最后，客户端对服务器的终止报文段进行确认。

![连接释放过程](https://s2.ax1x.com/2019/05/27/VVsT3V.png)

# 应用层

## HTTP请求
名称 |功能
----|------
GET	| 请求页面，并返回页面内容
HEAD	|类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
POST	|大多用于提交表单或者上传文件，数据包括在请求体中
PUT	 |从客户端向服务器传送的数据取代指定文档中的内容
DELETE	|请求服务器删除指定的页面
CONNECT	|把服务器当作跳板，让服务器代替客户端访问其他网页
OPTIONS	|允许客户端查看服务器的性能
TRACE	|回显服务器收到的请求，主要用于测试或者诊断

## HTTPS过程
SSL/TLS 是用来保障你的浏览器和网站服务器之间安全通信，免受网络“中间人”窃取信息。

1. 客户端生成一个随机数（随机数1）并将随机数和支持的加密套件发给服务端
2. 服务端选择加密套件，同时也生成一个随机数（随机数2），并将选择的加密套件、随机数2和CA证书发送给客户端
3. 客户端验证CA证书是否有效，如果有效，提取出证书中的公钥，生成一个新随机数3（预主密钥），并使用服务端公钥对预主密钥加密，发送给服务端
4. 服务端使用自己的私钥解密出预主密钥
5. 客户端和服务端结合随机数1、随机数2、预主密钥使用相同的算法生成一个会话密钥，用于业务信息的对称加密

### 证书的验证过程
服务端将公钥和站点信息等交给CA，CA审核通过后，颁发一个包含公钥、站点信息等明文信息和数字签名的证书。数字签名是通过对站点的明文信息使用特定的哈希函数进行计算并使用CA的私钥加密得到的。

客户端的浏览器内置了各大CA机构的公钥，在验证证书时，使用相同的哈希函数对证书的明文信息进行计算，得到哈希值1，再使用CA的公钥对证书的数字签名解密得到哈希值2，最后比较哈希值1和哈希值2，如果一致，则说明证书是可信的。

## HTTPS端口号
443

## HTTP状态码
* 1xx：请求还在处理中
* 2xx：处理成功的请求
    * 200 OK：不管什么请求方式(GET, POST, PUT, DELETE, HEAD...)，请求没问题
    * 201 Created：已创建一个新资源（主要针对PUT和POST）
    * 204 No Content：请求成功，但没有响应内容
* 3xx：重定向，资源被移去其他地方
    * 301 Moved Permanently：永久移动
    * 302 Found：暂时移动
    * 304 Not Modified：服务器资源未修改，直接使用本地缓存的内容
* 4xx：客户端问题
    * 400 Bad request：请求错误，无法理解
    * 401 Unauthorized：缺乏目标资源要求的身份验证凭证
    * 403 Forbidden：服务器端有能力处理该请求，但是拒绝授权访问
    * 404 Not Found：服务器无法找到所请求的资源
* 5xx：服务端问题
    * 500 Internal Server Error：服务端内部错误
    * 502 Bad Gateway：网关错误
    * 503 Service Unavailable：服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载

## DNS详细过程
1. 检查浏览器缓存中是否缓存过该域名对应的IP地址
2. 如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP
3. 向本地域名解析服务系统发起域名解析的请求
4. 本地域名解析服务器向根域名解析服务器发起域名解析请求
5. 根域名服务器返回顶级域名解析服务器地址
6. 本地域名服务器向顶级服务器发起解析请求
7. 顶级域名服务器返回权威dns服务器地址
8. 本地域名服务器询问权威域名服务器
9. 权威域名服务器向本地域名服务器返回IP地址
10. 本地域名服务器返回IP地址给用户
11. 用户通过IP地址发起HTTP请求
12. 服务器解析请求，并返回数据到用户

## HTTP1.0 HTTP 1.1主要区别

### 1.1 长链接

HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
### 1.2 节约带宽

HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。

这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。

另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础

### 1.3 支持HOST域
HTTP1.0是没有host域的，HTTP1.1才支持这个参数。

由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。

在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。

## HTTP1.1与HTTP 2.0的主要区别 

### 多路复用

### 二进制分帧

### 首部压缩

### 服务器推送

## arp协议的作用
将IP地址转换为MAC地址

## cookie是怎样被设置到浏览器的（HTTP响应首部字段）
1. 客户端K  通过浏览器L  第一次访问  服务器F
2. 服务器F  在HTTP通过set-cookie头部设置了一个标志客户端K的字符串回送到 客户端K
3. 客户端K的浏览器L检测到响应头部有set-cookie这个HTTP头部后，将他的值存储在硬盘中。

## HTTP2.0和1.0区别
HTTP2.0采用二进制传输数据，采用多路复用，压缩了报文头部，客户端在发起请求后服务器可以主动向客户端推送相关的资源，更加安全

## WebSocket特点
websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端全双工通信。websocket弥补了HTTP不支持长连接的特点

## 端口号范围
（1）公认端口（WellKnownPorts）

从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。

（2）注册端口（RegisteredPorts）

从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。

（3）动态和/或私有端口（Dynamicand/orPrivatePorts）

从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。

## 地址
A.在A类地址中，10.0.0.0到10.255.255.255是私有地址。所以应该是私有地址。
B.10.2.255.255的粗体字部分为主机号，主机号全为1的才是广播地址，10.255.255.255是广播地址。
C.对的这个地址主机号既不全为1，也不全为0，网络号也属于ABC类里的A类，所以是有效的。
D.10的2进制是0000 1010，所以是A类地址。

A类IP段：0.0.0.0 到 127.255.255.255 (0 段和 127 段不使用 )。

B类IP段：128.0.0.0 到 191.255.255.255，

C类IP段：192.0.0.0 到 223.255.255.255。

在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：
A类地址：10.0.0.0～10.255.255.255
B类地址：172.16.0.0～172.31.255.255
C类地址：192.168.0.0～192.168.255.255

## Cookie和Session的区别
1、存储位置不同
cookie的数据信息存放在客户端浏览器上。

session的数据信息存放在服务器上。

2、存储容量不同
单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。

对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。

3、存储方式不同
cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。

session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。

4、隐私策略不同
cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。

session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。

5、有效期上不同
开发可以通过设置cookie的属性，达到使cookie长期有效的效果。

session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。

6、服务器压力不同
cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。

session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。

7、浏览器支持不同
假如客户端浏览器不支持cookie：

cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。

运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。


8、 跨域
域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者跨域资源共享。

## HTTP 请求报文头部
* User-Agent：产生请求的浏览器类型。
* Accept：客户端可识别的响应内容类型列表;
* Accept-Language：客户端可接受的自然语言;
* Accept-Encoding：客户端可接受的编码压缩格式;
* Accept-Charset：可接受的应答的字符集;
* Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;（必选）
* Connection：连接方式(close 或 keep-alive);
* Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;
* 请求包体：在POST方法中使用。
* Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
* If-Modified-Since：文档的最后改动时间

## HTTP 响应头
* Allow 服务器支持哪些请求方法（如GET、POST等）。
* Content-Encoding 文档的编码（Encode）方法。
* Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。
* Content-Type 表示后面的文档属于什么MIME类型。
* Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
* Expires 应该在什么时候认为文档已经过期，从而不再缓存它。
* Last-Modified 文档的最后改动时间。
* Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。
* Server 服务器名字。
* Set-Cookie 设置和页面关联的Cookie。
* ETag：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。
* Cache-Control：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。

## http 状态码
* 1** 信息，服务器收到请求，需要请求者继续执行操作
* 2** 成功，操作被成功接收并处理
* 3** 重定向，需要进一步的操作以完成请求
    * 301 Moved Permanently。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
    * 302 Moved Temporarily。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
    * 304 Not Modified。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
* 4** 客户端错误，请求包含语法错误或无法完成请求
    * 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
    * 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
    * 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
    * 404 Not Found 请求的资源不存在，例如，输入了错误的URL
* 5** 服务器错误，服务器在处理请求的过程中发生了错误
    * 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
    * 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。


## 路由器和交换机的区别
路由器工作在网络层，根据IP地址寻址，交换机工作在数据链路层，根据MAC地址寻址。路由器可以隔绝广播域，交换机只能隔绝冲突域不能隔绝广播域

## TCP和UDP区别
* TCP是面向连接的，UDP是无连接的
* TCP是可靠的，UDP是不可靠的
* TCP是面向字节流的，UDP是面向数据报文的
* TCP只支持点对点通信，UDP支持一对一，一对多，多对多
* TCP报文首部20个字节，UDP首部8个字节
* TCP有拥塞控制和流量控制机制，UDP没有


### 面向报文、面向字节流
面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

### TCP为什么比UDP可靠
三次握手、快速重传（受到失序报文段后，连续发送对前一个按序到底报文段的确认，发送方受到三个冗余确认后，重传第一个失序报文段）、流量控制、拥塞控制（用到了快速重传）、四次挥手
#### 拥塞控制
慢启动和快恢复

### UDP的不可靠性
UDP不为IP提供可靠性、流控或差错恢复功能。由于UDP是无连接的，且没有超时重发等机制，故而传输速度很快。但相对的它只是把应用程序传给IP层的数据报发送出去，并不能保证它们能到达目的地。尤其在网络拥堵的时候，UDP也无法进行流量控制等避免网络拥塞的行为。就算出现了**丢包**的情况，UDP也不负责重发，甚至当出现包的到达**顺序乱掉**时也没有纠正的功能。

### TCP上的应用层协议
HTTP,FTP,SMTP,SSH,Telnet,POP3

### UDP上的应用层协议
NFS（网络文件系统）
TFTP
SNMP(Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理
DHCP
NTP(Network Time Protocol，网络时间协议) ，用于时间同步
BOOTP(Boot Protocol，启动协议) ，应用于无盘设备

## ping baidu.com命令用到的协议
DNS
ARP
ICMP 跟TCP和UDP没有归属关系，ICMP位于传输层之下，属网络层。用的IP报头

## 图片和html文件是否是一起传输
HTTP1.x里不是的，先请求HTML，再解析HTML并请求文件，HTTP2.0可以以push的方式在传输HTML的同时传输图片

## CSMA/CD
CSMA/CD是可抢占的半双工介质访问控制协议

## http 请求包含哪几个部分
请求行、请求头、请求体
### 请求行
请求方法字段、URL字段和HTTP协议版本
例如：GET /index.html HTTP/1.1
get方法将数据拼接在url后面，传递参数受限

请求方法：
GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

### 请求头
请求头(key value形式)
* User-Agent：产生请求的浏览器类型;

* Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;

* Accept-Language：客户端可接受的自然语言;

* Accept-Encoding：客户端可接受的编码压缩格式;

* Accept-Charset：可接受的应答的字符集;

* Host：指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。

* Connection： 决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。

* Referer： 包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。


* Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;

请求头和请求体之间有一个空行
### 请求体
post方法中，会在请求体中传送数据

## SYN Flood
传统的TCP连接中服务器在第二次握手即发送SYN+ACK响应时进入半开连接状态，此时会分配一些资源维护半开连接。攻击者可以大量伪造HTTP请求使得服务器不断分配资源给半开连接，从而无法正常提供服务。

解决方法：使用SYN Cookie，第二次连接时不分配资源，而是生成一个Cookie并返回客户端，客户端在第三次握手时能提供这个Cookie才真正分配资源建立连接

## 每一层协议
### 应用层
HTTP FTP DNS POP3 SMTP NTP SNMP NFS

会话层和表示层协议和应用层共用
一定要说的话
表示层：HTML、ASCII
会话层：SSH RPC

### 传输层
TCP UDP

### 网络层
IP协议
ICMP 互联网控制报文协议 用于主机和路由器交换信息，报错、回显请求等等
IGMP 用于广播和多播
路由协议：OSPF（链路状态），RIP（距离向量），BGP（距离向量）

### 数据链路层
CSMA/CA（带有冲突避免的载波监听多路访问协议，用于802.11）
CSMA/CD（带有冲突检测的载波监听多路访问协议，用于以太网）

### 物理层
802.3（以太网） 802.11（无线局域网）