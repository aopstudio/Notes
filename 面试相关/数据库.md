
# 事务
### 三种典型的不一致现象
#### 1. 脏读（读脏数据）
T2读取了T1修改但未提交的数据后，T1由于某种原因中止而撤销，这时T2就读取了不一致的数据。数据库中将这种读取未提交且被撤销的数据为读脏数据

#### 2. 不可重复读
事务T2两次从数据库中读取的结果不同，分为3种情况
1. T2读取一数据后，T1对该数据进行了更改，当T2再次读取该数据时，会读到和前一次不同的值 **（狭义的不可重复读）**
2. T2按某条件读取数据库中某些记录后，T1删除了其中部分记录。当T2再次按相同条件读取时，发现记录数变少了
3. T2按某条件读取数据库中某些记录后，T1插入了新的纪录。当T2再次按相同条件读取时，发现记录数变多了

2和3这两种情况也称为**幻读**
#### 3. 丢失更新
两个或多个事务都读取了同一数据值并修改，最后提交的事务执行结果覆盖了前面事务提交的执行结果，从而导致前面事务的更新被丢失

### 事务的隔离级别
#### 1. 读未提交
未提交读，允许事务读取未提交的数据，脏读、不可重复读和幻读都可能发生
#### 2. 读已提交
只允许读取已经提交的数据，避免脏读，但不可重复读仍可能发生
#### 3. 可重复读
保证在同一个事务中多次读取同样数据的结果是一样的，避免脏读和不可重复读（除幻读外），但幻读仍可能发生。

MySQL InnoDB 存储引擎的默认支持的隔离级别
#### 4. 可串行化
保证事务串行化执行，避免脏读、不可重复读和幻读，但执行效率低


## 事务的ACID特性
### 原子性
事务的所有操作要么全部都被执行，要么都不被执行
### 一致性
一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。比如银行转账，一边账户的钱少了，另一边账户的钱必须多，不能丢失
### 隔离性
当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰
### 持久性
一个事务成功提交后，它对数据库的改变必须是永久的，即使随后系统出现故障也不会受到影响

# MySQL
MySQL中常用的索引结构（索引底层的数据结构）有：B-TREE ，B+TREE ，HASH 等

## B-TREE
B-树就是B树，多路搜索树，树高一层意味着多一次的磁盘I/O

B树的特征：

* 关键字集合分布在整颗树中；
* 任何一个关键字出现且只出现在一个结点中；
* 搜索有可能在非叶子结点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找；
* 自动层次控制
## B+TREE
B+树是B-树的变体，也是一种多路搜索树

B+树的特征：

* 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
* 不可能在非叶子结点命中；
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
* 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
* 更适合文件索引系统；

## InnoDB采用B+树作为索引的原因
1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。



# MySQL
## MySQL如何保证ACID
### 原子性

### 一致性

### 隔离性
#### 锁
从粒度上来说就是表锁、页锁、行锁

表锁有意向共享锁、意向排他锁、自增锁等

行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁

在 InnoDB 事务中，行锁通过给索引上的索引项加锁来实现。 这意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。 行级锁定同样分为两种类型：共享锁 和 排他锁，以及加锁前需要先获得的意向共享锁和意向排他锁

行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议

### 持久性


## MySQL引擎
* MyISAM

* InnoDB

### 两者的特点和区别
#### 事务
MyISAM：不支持事务
InnoDB：支持事务，并支持4个事务隔离级别
#### 锁定类型
MyISAM：表级锁定形式，数据在更新时锁定整个表
InnoDB：行级锁定，但是全表扫描仍然会是表级锁定
#### 读写过程
MyISAM：数据库在读写过程中相互阻塞
会在数据写入的过程阻塞用户数据的读取
也会在数据读取的过程中阻塞用户的数据写入

InnoDB：读写阻塞与事务隔离级别相关
#### 外键约束
MyISAM：MyISAM存储引擎它不支持外键约束

InnoDB：支持外键约束
#### 读写性能
MyISAM：读取性能优越，但是写入性能差
如果执行大量的select，MyISAM是更好的选择

InnoDB：写入性能较强
如果执行大量的insert或者update，InnoDB是更好的选择



## 索引
### 索引失效

### B+树索引


# Redis
## 各种数据类型及其内部实现

zset的的底层实现，查找时间复杂度
